Date: Wed, 8 Mar 2017 04:45:39 +0300
Subject: patch for bullet3-2.86.1

---
 .../BroadphaseCollision/btAxisSweep3.h             | 1000 +-------------------
 .../BroadphaseCollision/btBroadphaseInterface.h    |    4 +
 .../btOverlappingPairCallback.h                    |    3 +
 bullet/BulletCollision/CMakeLists.txt              |    4 +
 .../btActivatingCollisionAlgorithm.h               |    3 +-
 .../CollisionDispatch/btCollisionWorldImporter.h   |    2 +-
 .../btCompoundCompoundCollisionAlgorithm.h         |    2 -
 .../CollisionDispatch/btManifoldResult.cpp         |    5 +
 .../CollisionShapes/btPolyhedralConvexShape.h      |    4 +-
 bullet/BulletCollision/Gimpact/btBoxCollision.h    |   19 +-
 .../BulletCollision/Gimpact/btContactProcessing.h  |   82 +-
 bullet/BulletCollision/Gimpact/btGImpactBvh.h      |   80 +-
 .../Gimpact/btGImpactQuantizedBvh.h                |   69 +-
 bullet/BulletCollision/Gimpact/gim_array.h         |    2 +-
 .../Gimpact/gim_basic_geometry_operations.h        |    7 +-
 bullet/BulletCollision/Gimpact/gim_box_collision.h |    9 +-
 bullet/BulletCollision/Gimpact/gim_contact.h       |    8 +
 bullet/BulletCollision/Gimpact/gim_tri_collision.h |    3 +-
 .../btDiscreteCollisionDetectorInterface.h         |    4 +-
 .../NarrowPhaseCollision/btPersistentManifold.cpp  |    2 +
 .../NarrowPhaseCollision/btPersistentManifold.h    |   18 +
 .../ConstraintSolver/btContactConstraint.h         |    4 +-
 bullet/BulletDynamics/Vehicle/btRaycastVehicle.h   |    2 +-
 bullet/BulletDynamics/Vehicle/btWheelInfo.h        |    2 +
 bullet/BulletInverseDynamics/IDConfig.hpp          |    6 +-
 bullet/BulletInverseDynamics/IDConfigBuiltin.hpp   |   37 -
 bullet/BulletInverseDynamics/IDConfigEigen.hpp     |   31 -
 .../details/IDEigenInterface.hpp                   |   36 -
 bullet/BulletInverseDynamics/details/IDMatVec.hpp  |  415 --------
 bullet/BulletSoftBody/btSoftBody.h                 |    2 +-
 .../BulletSoftBody/btSoftMultiBodyDynamicsWorld.h  |    2 +
 bullet/LinearMath/btQuickprof.h                    |    4 +-
 bullet/LinearMath/btScalar.h                       |    9 +-
 .../BulletInverseDynamicsUtilsCommon.h             |    2 +-
 extras/InverseDynamics/btMultiBodyFromURDF.hpp     |   91 --
 .../BroadphaseCollision/btAxisSweep3Internal.h     | 1022 ++++++++++++++++++++
 .../Gimpact/btContactProcessingSructs.h            |  138 +++
 .../BulletCollision/Gimpact/btGImpactBvhSructs.h   |  161 +++
 .../Gimpact/btGImpactQuantizedBvhSructs.h          |  124 +++
 35 files changed, 111 insertions(+), 1862 deletions(-)
 delete mode 100644 bullet/BulletInverseDynamics/IDConfigBuiltin.hpp
 delete mode 100644 bullet/BulletInverseDynamics/IDConfigEigen.hpp
 delete mode 100644 bullet/BulletInverseDynamics/details/IDEigenInterface.hpp
 delete mode 100644 bullet/BulletInverseDynamics/details/IDMatVec.hpp
 delete mode 100644 extras/InverseDynamics/btMultiBodyFromURDF.hpp
 create mode 100644 bullet/BulletCollision/BroadphaseCollision/btAxisSweep3Internal.h
 create mode 100644 bullet/BulletCollision/Gimpact/btContactProcessingSructs.h
 create mode 100644 bullet/BulletCollision/Gimpact/btGImpactBvhSructs.h
 create mode 100644 bullet/BulletCollision/Gimpact/btGImpactQuantizedBvhSructs.h

diff --git a/bullet/BulletCollision/BroadphaseCollision/btAxisSweep3.h b/bullet/BulletCollision/BroadphaseCollision/btAxisSweep3.h
index 58e3524..a3648df 100644
--- a/bullet/BulletCollision/BroadphaseCollision/btAxisSweep3.h
+++ b/bullet/BulletCollision/BroadphaseCollision/btAxisSweep3.h
@@ -25,1004 +25,7 @@
 #include "btBroadphaseProxy.h"
 #include "btOverlappingPairCallback.h"
 #include "btDbvtBroadphase.h"
-
-//#define DEBUG_BROADPHASE 1
-#define USE_OVERLAP_TEST_ON_REMOVES 1
-
-/// The internal templace class btAxisSweep3Internal implements the sweep and prune broadphase.
-/// It uses quantized integers to represent the begin and end points for each of the 3 axis.
-/// Dont use this class directly, use btAxisSweep3 or bt32BitAxisSweep3 instead.
-template <typename BP_FP_INT_TYPE>
-class btAxisSweep3Internal : public btBroadphaseInterface
-{
-protected:
-
-	BP_FP_INT_TYPE	m_bpHandleMask;
-	BP_FP_INT_TYPE	m_handleSentinel;
-
-public:
-	
- BT_DECLARE_ALIGNED_ALLOCATOR();
-
-	class Edge
-	{
-	public:
-		BP_FP_INT_TYPE m_pos;			// low bit is min/max
-		BP_FP_INT_TYPE m_handle;
-
-		BP_FP_INT_TYPE IsMax() const {return static_cast<BP_FP_INT_TYPE>(m_pos & 1);}
-	};
-
-public:
-	class	Handle : public btBroadphaseProxy
-	{
-	public:
-	BT_DECLARE_ALIGNED_ALLOCATOR();
-	
-		// indexes into the edge arrays
-		BP_FP_INT_TYPE m_minEdges[3], m_maxEdges[3];		// 6 * 2 = 12
-//		BP_FP_INT_TYPE m_uniqueId;
-		btBroadphaseProxy*	m_dbvtProxy;//for faster raycast
-		//void* m_pOwner; this is now in btBroadphaseProxy.m_clientObject
-	
-		SIMD_FORCE_INLINE void SetNextFree(BP_FP_INT_TYPE next) {m_minEdges[0] = next;}
-		SIMD_FORCE_INLINE BP_FP_INT_TYPE GetNextFree() const {return m_minEdges[0];}
-	};		// 24 bytes + 24 for Edge structures = 44 bytes total per entry
-
-	
-protected:
-	btVector3 m_worldAabbMin;						// overall system bounds
-	btVector3 m_worldAabbMax;						// overall system bounds
-
-	btVector3 m_quantize;						// scaling factor for quantization
-
-	BP_FP_INT_TYPE m_numHandles;						// number of active handles
-	BP_FP_INT_TYPE m_maxHandles;						// max number of handles
-	Handle* m_pHandles;						// handles pool
-	
-	BP_FP_INT_TYPE m_firstFreeHandle;		// free handles list
-
-	Edge* m_pEdges[3];						// edge arrays for the 3 axes (each array has m_maxHandles * 2 + 2 sentinel entries)
-	void* m_pEdgesRawPtr[3];
-
-	btOverlappingPairCache* m_pairCache;
-
-	///btOverlappingPairCallback is an additional optional user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
-	btOverlappingPairCallback* m_userPairCallback;
-	
-	bool	m_ownsPairCache;
-
-	int	m_invalidPair;
-
-	///additional dynamic aabb structure, used to accelerate ray cast queries.
-	///can be disabled using a optional argument in the constructor
-	btDbvtBroadphase*	m_raycastAccelerator;
-	btOverlappingPairCache*	m_nullPairCache;
-
-
-	// allocation/deallocation
-	BP_FP_INT_TYPE allocHandle();
-	void freeHandle(BP_FP_INT_TYPE handle);
-	
-
-	bool testOverlap2D(const Handle* pHandleA, const Handle* pHandleB,int axis0,int axis1);
-
-#ifdef DEBUG_BROADPHASE
-	void debugPrintAxis(int axis,bool checkCardinality=true);
-#endif //DEBUG_BROADPHASE
-
-	//Overlap* AddOverlap(BP_FP_INT_TYPE handleA, BP_FP_INT_TYPE handleB);
-	//void RemoveOverlap(BP_FP_INT_TYPE handleA, BP_FP_INT_TYPE handleB);
-
-	
-
-	void sortMinDown(int axis, BP_FP_INT_TYPE edge, btDispatcher* dispatcher, bool updateOverlaps );
-	void sortMinUp(int axis, BP_FP_INT_TYPE edge, btDispatcher* dispatcher, bool updateOverlaps );
-	void sortMaxDown(int axis, BP_FP_INT_TYPE edge, btDispatcher* dispatcher, bool updateOverlaps );
-	void sortMaxUp(int axis, BP_FP_INT_TYPE edge, btDispatcher* dispatcher, bool updateOverlaps );
-
-public:
-
-	btAxisSweep3Internal(const btVector3& worldAabbMin,const btVector3& worldAabbMax, BP_FP_INT_TYPE handleMask, BP_FP_INT_TYPE handleSentinel, BP_FP_INT_TYPE maxHandles = 16384, btOverlappingPairCache* pairCache=0,bool disableRaycastAccelerator = false);
-
-	virtual	~btAxisSweep3Internal();
-
-	BP_FP_INT_TYPE getNumHandles() const
-	{
-		return m_numHandles;
-	}
-
-	virtual void	calculateOverlappingPairs(btDispatcher* dispatcher);
-	
-	BP_FP_INT_TYPE addHandle(const btVector3& aabbMin,const btVector3& aabbMax, void* pOwner, int collisionFilterGroup, int collisionFilterMask,btDispatcher* dispatcher);
-	void removeHandle(BP_FP_INT_TYPE handle,btDispatcher* dispatcher);
-	void updateHandle(BP_FP_INT_TYPE handle, const btVector3& aabbMin,const btVector3& aabbMax,btDispatcher* dispatcher);
-	SIMD_FORCE_INLINE Handle* getHandle(BP_FP_INT_TYPE index) const {return m_pHandles + index;}
-
-	virtual void resetPool(btDispatcher* dispatcher);
-
-	void	processAllOverlappingPairs(btOverlapCallback* callback);
-
-	//Broadphase Interface
-	virtual btBroadphaseProxy*	createProxy(  const btVector3& aabbMin,  const btVector3& aabbMax,int shapeType,void* userPtr , int collisionFilterGroup, int collisionFilterMask,btDispatcher* dispatcher);
-	virtual void	destroyProxy(btBroadphaseProxy* proxy,btDispatcher* dispatcher);
-	virtual void	setAabb(btBroadphaseProxy* proxy,const btVector3& aabbMin,const btVector3& aabbMax,btDispatcher* dispatcher);
-	virtual void  getAabb(btBroadphaseProxy* proxy,btVector3& aabbMin, btVector3& aabbMax ) const;
-	
-	virtual void	rayTest(const btVector3& rayFrom,const btVector3& rayTo, btBroadphaseRayCallback& rayCallback, const btVector3& aabbMin=btVector3(0,0,0), const btVector3& aabbMax = btVector3(0,0,0));
-	virtual void	aabbTest(const btVector3& aabbMin, const btVector3& aabbMax, btBroadphaseAabbCallback& callback);
-
-	
-	void quantize(BP_FP_INT_TYPE* out, const btVector3& point, int isMax) const;
-	///unQuantize should be conservative: aabbMin/aabbMax should be larger then 'getAabb' result
-	void unQuantize(btBroadphaseProxy* proxy,btVector3& aabbMin, btVector3& aabbMax ) const;
-	
-	bool	testAabbOverlap(btBroadphaseProxy* proxy0,btBroadphaseProxy* proxy1);
-
-	btOverlappingPairCache*	getOverlappingPairCache()
-	{
-		return m_pairCache;
-	}
-	const btOverlappingPairCache*	getOverlappingPairCache() const
-	{
-		return m_pairCache;
-	}
-
-	void	setOverlappingPairUserCallback(btOverlappingPairCallback* pairCallback)
-	{
-		m_userPairCallback = pairCallback;
-	}
-	const btOverlappingPairCallback*	getOverlappingPairUserCallback() const
-	{
-		return m_userPairCallback;
-	}
-
-	///getAabb returns the axis aligned bounding box in the 'global' coordinate frame
-	///will add some transform later
-	virtual void getBroadphaseAabb(btVector3& aabbMin,btVector3& aabbMax) const
-	{
-		aabbMin = m_worldAabbMin;
-		aabbMax = m_worldAabbMax;
-	}
-
-	virtual void	printStats()
-	{
-/*		printf("btAxisSweep3.h\n");
-		printf("numHandles = %d, maxHandles = %d\n",m_numHandles,m_maxHandles);
-		printf("aabbMin=%f,%f,%f,aabbMax=%f,%f,%f\n",m_worldAabbMin.getX(),m_worldAabbMin.getY(),m_worldAabbMin.getZ(),
-			m_worldAabbMax.getX(),m_worldAabbMax.getY(),m_worldAabbMax.getZ());
-			*/
-
-	}
-
-};
-
-////////////////////////////////////////////////////////////////////
-
-
-
-
-#ifdef DEBUG_BROADPHASE
-#include <stdio.h>
-
-template <typename BP_FP_INT_TYPE>
-void btAxisSweep3<BP_FP_INT_TYPE>::debugPrintAxis(int axis, bool checkCardinality)
-{
-	int numEdges = m_pHandles[0].m_maxEdges[axis];
-	printf("SAP Axis %d, numEdges=%d\n",axis,numEdges);
-
-	int i;
-	for (i=0;i<numEdges+1;i++)
-	{
-		Edge* pEdge = m_pEdges[axis] + i;
-		Handle* pHandlePrev = getHandle(pEdge->m_handle);
-		int handleIndex = pEdge->IsMax()? pHandlePrev->m_maxEdges[axis] : pHandlePrev->m_minEdges[axis];
-		char beginOrEnd;
-		beginOrEnd=pEdge->IsMax()?'E':'B';
-		printf("	[%c,h=%d,p=%x,i=%d]\n",beginOrEnd,pEdge->m_handle,pEdge->m_pos,handleIndex);
-	}
-
-	if (checkCardinality)
-		btAssert(numEdges == m_numHandles*2+1);
-}
-#endif //DEBUG_BROADPHASE
-
-template <typename BP_FP_INT_TYPE>
-btBroadphaseProxy*	btAxisSweep3Internal<BP_FP_INT_TYPE>::createProxy(  const btVector3& aabbMin,  const btVector3& aabbMax,int shapeType,void* userPtr, int collisionFilterGroup, int collisionFilterMask,btDispatcher* dispatcher)
-{
-		(void)shapeType;
-		BP_FP_INT_TYPE handleId = addHandle(aabbMin,aabbMax, userPtr,collisionFilterGroup,collisionFilterMask,dispatcher);
-		
-		Handle* handle = getHandle(handleId);
-		
-		if (m_raycastAccelerator)
-		{
-			btBroadphaseProxy* rayProxy = m_raycastAccelerator->createProxy(aabbMin,aabbMax,shapeType,userPtr,collisionFilterGroup,collisionFilterMask,dispatcher);
-			handle->m_dbvtProxy = rayProxy;
-		}
-		return handle;
-}
-
-
-
-template <typename BP_FP_INT_TYPE>
-void	btAxisSweep3Internal<BP_FP_INT_TYPE>::destroyProxy(btBroadphaseProxy* proxy,btDispatcher* dispatcher)
-{
-	Handle* handle = static_cast<Handle*>(proxy);
-	if (m_raycastAccelerator)
-		m_raycastAccelerator->destroyProxy(handle->m_dbvtProxy,dispatcher);
-	removeHandle(static_cast<BP_FP_INT_TYPE>(handle->m_uniqueId), dispatcher);
-}
-
-template <typename BP_FP_INT_TYPE>
-void	btAxisSweep3Internal<BP_FP_INT_TYPE>::setAabb(btBroadphaseProxy* proxy,const btVector3& aabbMin,const btVector3& aabbMax,btDispatcher* dispatcher)
-{
-	Handle* handle = static_cast<Handle*>(proxy);
-	handle->m_aabbMin = aabbMin;
-	handle->m_aabbMax = aabbMax;
-	updateHandle(static_cast<BP_FP_INT_TYPE>(handle->m_uniqueId), aabbMin, aabbMax,dispatcher);
-	if (m_raycastAccelerator)
-		m_raycastAccelerator->setAabb(handle->m_dbvtProxy,aabbMin,aabbMax,dispatcher);
-
-}
-
-template <typename BP_FP_INT_TYPE>
-void	btAxisSweep3Internal<BP_FP_INT_TYPE>::rayTest(const btVector3& rayFrom,const btVector3& rayTo, btBroadphaseRayCallback& rayCallback,const btVector3& aabbMin,const btVector3& aabbMax)
-{
-	if (m_raycastAccelerator)
-	{
-		m_raycastAccelerator->rayTest(rayFrom,rayTo,rayCallback,aabbMin,aabbMax);
-	} else
-	{
-		//choose axis?
-		BP_FP_INT_TYPE axis = 0;
-		//for each proxy
-		for (BP_FP_INT_TYPE i=1;i<m_numHandles*2+1;i++)
-		{
-			if (m_pEdges[axis][i].IsMax())
-			{
-				rayCallback.process(getHandle(m_pEdges[axis][i].m_handle));
-			}
-		}
-	}
-}
-
-template <typename BP_FP_INT_TYPE>
-void	btAxisSweep3Internal<BP_FP_INT_TYPE>::aabbTest(const btVector3& aabbMin, const btVector3& aabbMax, btBroadphaseAabbCallback& callback)
-{
-	if (m_raycastAccelerator)
-	{
-		m_raycastAccelerator->aabbTest(aabbMin,aabbMax,callback);
-	} else
-	{
-		//choose axis?
-		BP_FP_INT_TYPE axis = 0;
-		//for each proxy
-		for (BP_FP_INT_TYPE i=1;i<m_numHandles*2+1;i++)
-		{
-			if (m_pEdges[axis][i].IsMax())
-			{
-				Handle* handle = getHandle(m_pEdges[axis][i].m_handle);
-				if (TestAabbAgainstAabb2(aabbMin,aabbMax,handle->m_aabbMin,handle->m_aabbMax))
-				{
-					callback.process(handle);
-				}
-			}
-		}
-	}
-}
-
-
-
-template <typename BP_FP_INT_TYPE>
-void btAxisSweep3Internal<BP_FP_INT_TYPE>::getAabb(btBroadphaseProxy* proxy,btVector3& aabbMin, btVector3& aabbMax ) const
-{
-	Handle* pHandle = static_cast<Handle*>(proxy);
-	aabbMin = pHandle->m_aabbMin;
-	aabbMax = pHandle->m_aabbMax;
-}
-
-
-template <typename BP_FP_INT_TYPE>
-void btAxisSweep3Internal<BP_FP_INT_TYPE>::unQuantize(btBroadphaseProxy* proxy,btVector3& aabbMin, btVector3& aabbMax ) const
-{
-	Handle* pHandle = static_cast<Handle*>(proxy);
-
-	unsigned short vecInMin[3];
-	unsigned short vecInMax[3];
-
-	vecInMin[0] = m_pEdges[0][pHandle->m_minEdges[0]].m_pos ;
-	vecInMax[0] = m_pEdges[0][pHandle->m_maxEdges[0]].m_pos +1 ;
-	vecInMin[1] = m_pEdges[1][pHandle->m_minEdges[1]].m_pos ;
-	vecInMax[1] = m_pEdges[1][pHandle->m_maxEdges[1]].m_pos +1 ;
-	vecInMin[2] = m_pEdges[2][pHandle->m_minEdges[2]].m_pos ;
-	vecInMax[2] = m_pEdges[2][pHandle->m_maxEdges[2]].m_pos +1 ;
-	
-	aabbMin.setValue((btScalar)(vecInMin[0]) / (m_quantize.getX()),(btScalar)(vecInMin[1]) / (m_quantize.getY()),(btScalar)(vecInMin[2]) / (m_quantize.getZ()));
-	aabbMin += m_worldAabbMin;
-	
-	aabbMax.setValue((btScalar)(vecInMax[0]) / (m_quantize.getX()),(btScalar)(vecInMax[1]) / (m_quantize.getY()),(btScalar)(vecInMax[2]) / (m_quantize.getZ()));
-	aabbMax += m_worldAabbMin;
-}
-
-
-
-
-template <typename BP_FP_INT_TYPE>
-btAxisSweep3Internal<BP_FP_INT_TYPE>::btAxisSweep3Internal(const btVector3& worldAabbMin,const btVector3& worldAabbMax, BP_FP_INT_TYPE handleMask, BP_FP_INT_TYPE handleSentinel,BP_FP_INT_TYPE userMaxHandles, btOverlappingPairCache* pairCache , bool disableRaycastAccelerator)
-:m_bpHandleMask(handleMask),
-m_handleSentinel(handleSentinel),
-m_pairCache(pairCache),
-m_userPairCallback(0),
-m_ownsPairCache(false),
-m_invalidPair(0),
-m_raycastAccelerator(0)
-{
-	BP_FP_INT_TYPE maxHandles = static_cast<BP_FP_INT_TYPE>(userMaxHandles+1);//need to add one sentinel handle
-
-	if (!m_pairCache)
-	{
-		void* ptr = btAlignedAlloc(sizeof(btHashedOverlappingPairCache),16);
-		m_pairCache = new(ptr) btHashedOverlappingPairCache();
-		m_ownsPairCache = true;
-	}
-
-	if (!disableRaycastAccelerator)
-	{
-		m_nullPairCache = new (btAlignedAlloc(sizeof(btNullPairCache),16)) btNullPairCache();
-		m_raycastAccelerator = new (btAlignedAlloc(sizeof(btDbvtBroadphase),16)) btDbvtBroadphase(m_nullPairCache);//m_pairCache);
-		m_raycastAccelerator->m_deferedcollide = true;//don't add/remove pairs
-	}
-
-	//btAssert(bounds.HasVolume());
-
-	// init bounds
-	m_worldAabbMin = worldAabbMin;
-	m_worldAabbMax = worldAabbMax;
-
-	btVector3 aabbSize = m_worldAabbMax - m_worldAabbMin;
-
-	BP_FP_INT_TYPE	maxInt = m_handleSentinel;
-
-	m_quantize = btVector3(btScalar(maxInt),btScalar(maxInt),btScalar(maxInt)) / aabbSize;
-
-	// allocate handles buffer, using btAlignedAlloc, and put all handles on free list
-	m_pHandles = new Handle[maxHandles];
-	
-	m_maxHandles = maxHandles;
-	m_numHandles = 0;
-
-	// handle 0 is reserved as the null index, and is also used as the sentinel
-	m_firstFreeHandle = 1;
-	{
-		for (BP_FP_INT_TYPE i = m_firstFreeHandle; i < maxHandles; i++)
-			m_pHandles[i].SetNextFree(static_cast<BP_FP_INT_TYPE>(i + 1));
-		m_pHandles[maxHandles - 1].SetNextFree(0);
-	}
-
-	{
-		// allocate edge buffers
-		for (int i = 0; i < 3; i++)
-		{
-			m_pEdgesRawPtr[i] = btAlignedAlloc(sizeof(Edge)*maxHandles*2,16);
-			m_pEdges[i] = new(m_pEdgesRawPtr[i]) Edge[maxHandles * 2];
-		}
-	}
-	//removed overlap management
-
-	// make boundary sentinels
-	
-	m_pHandles[0].m_clientObject = 0;
-
-	for (int axis = 0; axis < 3; axis++)
-	{
-		m_pHandles[0].m_minEdges[axis] = 0;
-		m_pHandles[0].m_maxEdges[axis] = 1;
-
-		m_pEdges[axis][0].m_pos = 0;
-		m_pEdges[axis][0].m_handle = 0;
-		m_pEdges[axis][1].m_pos = m_handleSentinel;
-		m_pEdges[axis][1].m_handle = 0;
-#ifdef DEBUG_BROADPHASE
-		debugPrintAxis(axis);
-#endif //DEBUG_BROADPHASE
-
-	}
-
-}
-
-template <typename BP_FP_INT_TYPE>
-btAxisSweep3Internal<BP_FP_INT_TYPE>::~btAxisSweep3Internal()
-{
-	if (m_raycastAccelerator)
-	{
-		m_nullPairCache->~btOverlappingPairCache();
-		btAlignedFree(m_nullPairCache);
-		m_raycastAccelerator->~btDbvtBroadphase();
-		btAlignedFree (m_raycastAccelerator);
-	}
-
-	for (int i = 2; i >= 0; i--)
-	{
-		btAlignedFree(m_pEdgesRawPtr[i]);
-	}
-	delete [] m_pHandles;
-
-	if (m_ownsPairCache)
-	{
-		m_pairCache->~btOverlappingPairCache();
-		btAlignedFree(m_pairCache);
-	}
-}
-
-template <typename BP_FP_INT_TYPE>
-void btAxisSweep3Internal<BP_FP_INT_TYPE>::quantize(BP_FP_INT_TYPE* out, const btVector3& point, int isMax) const
-{
-#ifdef OLD_CLAMPING_METHOD
-	///problem with this clamping method is that the floating point during quantization might still go outside the range [(0|isMax) .. (m_handleSentinel&m_bpHandleMask]|isMax]
-	///see http://code.google.com/p/bullet/issues/detail?id=87
-	btVector3 clampedPoint(point);
-	clampedPoint.setMax(m_worldAabbMin);
-	clampedPoint.setMin(m_worldAabbMax);
-	btVector3 v = (clampedPoint - m_worldAabbMin) * m_quantize;
-	out[0] = (BP_FP_INT_TYPE)(((BP_FP_INT_TYPE)v.getX() & m_bpHandleMask) | isMax);
-	out[1] = (BP_FP_INT_TYPE)(((BP_FP_INT_TYPE)v.getY() & m_bpHandleMask) | isMax);
-	out[2] = (BP_FP_INT_TYPE)(((BP_FP_INT_TYPE)v.getZ() & m_bpHandleMask) | isMax);
-#else
-	btVector3 v = (point - m_worldAabbMin) * m_quantize;
-	out[0]=(v[0]<=0)?(BP_FP_INT_TYPE)isMax:(v[0]>=m_handleSentinel)?(BP_FP_INT_TYPE)((m_handleSentinel&m_bpHandleMask)|isMax):(BP_FP_INT_TYPE)(((BP_FP_INT_TYPE)v[0]&m_bpHandleMask)|isMax);
-	out[1]=(v[1]<=0)?(BP_FP_INT_TYPE)isMax:(v[1]>=m_handleSentinel)?(BP_FP_INT_TYPE)((m_handleSentinel&m_bpHandleMask)|isMax):(BP_FP_INT_TYPE)(((BP_FP_INT_TYPE)v[1]&m_bpHandleMask)|isMax);
-	out[2]=(v[2]<=0)?(BP_FP_INT_TYPE)isMax:(v[2]>=m_handleSentinel)?(BP_FP_INT_TYPE)((m_handleSentinel&m_bpHandleMask)|isMax):(BP_FP_INT_TYPE)(((BP_FP_INT_TYPE)v[2]&m_bpHandleMask)|isMax);
-#endif //OLD_CLAMPING_METHOD
-}
-
-
-template <typename BP_FP_INT_TYPE>
-BP_FP_INT_TYPE btAxisSweep3Internal<BP_FP_INT_TYPE>::allocHandle()
-{
-	btAssert(m_firstFreeHandle);
-
-	BP_FP_INT_TYPE handle = m_firstFreeHandle;
-	m_firstFreeHandle = getHandle(handle)->GetNextFree();
-	m_numHandles++;
-
-	return handle;
-}
-
-template <typename BP_FP_INT_TYPE>
-void btAxisSweep3Internal<BP_FP_INT_TYPE>::freeHandle(BP_FP_INT_TYPE handle)
-{
-	btAssert(handle > 0 && handle < m_maxHandles);
-
-	getHandle(handle)->SetNextFree(m_firstFreeHandle);
-	m_firstFreeHandle = handle;
-
-	m_numHandles--;
-}
-
-
-template <typename BP_FP_INT_TYPE>
-BP_FP_INT_TYPE btAxisSweep3Internal<BP_FP_INT_TYPE>::addHandle(const btVector3& aabbMin,const btVector3& aabbMax, void* pOwner, int collisionFilterGroup, int collisionFilterMask,btDispatcher* dispatcher)
-{
-	// quantize the bounds
-	BP_FP_INT_TYPE min[3], max[3];
-	quantize(min, aabbMin, 0);
-	quantize(max, aabbMax, 1);
-
-	// allocate a handle
-	BP_FP_INT_TYPE handle = allocHandle();
-	
-
-	Handle* pHandle = getHandle(handle);
-	
-	pHandle->m_uniqueId = static_cast<int>(handle);
-	//pHandle->m_pOverlaps = 0;
-	pHandle->m_clientObject = pOwner;
-	pHandle->m_collisionFilterGroup = collisionFilterGroup;
-	pHandle->m_collisionFilterMask = collisionFilterMask;
-
-	// compute current limit of edge arrays
-	BP_FP_INT_TYPE limit = static_cast<BP_FP_INT_TYPE>(m_numHandles * 2);
-
-	
-	// insert new edges just inside the max boundary edge
-	for (BP_FP_INT_TYPE axis = 0; axis < 3; axis++)
-	{
-
-		m_pHandles[0].m_maxEdges[axis] += 2;
-
-		m_pEdges[axis][limit + 1] = m_pEdges[axis][limit - 1];
-
-		m_pEdges[axis][limit - 1].m_pos = min[axis];
-		m_pEdges[axis][limit - 1].m_handle = handle;
-
-		m_pEdges[axis][limit].m_pos = max[axis];
-		m_pEdges[axis][limit].m_handle = handle;
-
-		pHandle->m_minEdges[axis] = static_cast<BP_FP_INT_TYPE>(limit - 1);
-		pHandle->m_maxEdges[axis] = limit;
-	}
-
-	// now sort the new edges to their correct position
-	sortMinDown(0, pHandle->m_minEdges[0], dispatcher,false);
-	sortMaxDown(0, pHandle->m_maxEdges[0], dispatcher,false);
-	sortMinDown(1, pHandle->m_minEdges[1], dispatcher,false);
-	sortMaxDown(1, pHandle->m_maxEdges[1], dispatcher,false);
-	sortMinDown(2, pHandle->m_minEdges[2], dispatcher,true);
-	sortMaxDown(2, pHandle->m_maxEdges[2], dispatcher,true);
-
-
-	return handle;
-}
-
-
-template <typename BP_FP_INT_TYPE>
-void btAxisSweep3Internal<BP_FP_INT_TYPE>::removeHandle(BP_FP_INT_TYPE handle,btDispatcher* dispatcher)
-{
-
-	Handle* pHandle = getHandle(handle);
-
-	//explicitly remove the pairs containing the proxy
-	//we could do it also in the sortMinUp (passing true)
-	///@todo: compare performance
-	if (!m_pairCache->hasDeferredRemoval())
-	{
-		m_pairCache->removeOverlappingPairsContainingProxy(pHandle,dispatcher);
-	}
-
-	// compute current limit of edge arrays
-	int limit = static_cast<int>(m_numHandles * 2);
-	
-	int axis;
-
-	for (axis = 0;axis<3;axis++)
-	{
-		m_pHandles[0].m_maxEdges[axis] -= 2;
-	}
-
-	// remove the edges by sorting them up to the end of the list
-	for ( axis = 0; axis < 3; axis++)
-	{
-		Edge* pEdges = m_pEdges[axis];
-		BP_FP_INT_TYPE max = pHandle->m_maxEdges[axis];
-		pEdges[max].m_pos = m_handleSentinel;
-
-		sortMaxUp(axis,max,dispatcher,false);
-
-
-		BP_FP_INT_TYPE i = pHandle->m_minEdges[axis];
-		pEdges[i].m_pos = m_handleSentinel;
-
-
-		sortMinUp(axis,i,dispatcher,false);
-
-		pEdges[limit-1].m_handle = 0;
-		pEdges[limit-1].m_pos = m_handleSentinel;
-		
-#ifdef DEBUG_BROADPHASE
-			debugPrintAxis(axis,false);
-#endif //DEBUG_BROADPHASE
-
-
-	}
-
-
-	// free the handle
-	freeHandle(handle);
-
-	
-}
-
-template <typename BP_FP_INT_TYPE>
-void btAxisSweep3Internal<BP_FP_INT_TYPE>::resetPool(btDispatcher* /*dispatcher*/)
-{
-	if (m_numHandles == 0)
-	{
-		m_firstFreeHandle = 1;
-		{
-			for (BP_FP_INT_TYPE i = m_firstFreeHandle; i < m_maxHandles; i++)
-				m_pHandles[i].SetNextFree(static_cast<BP_FP_INT_TYPE>(i + 1));
-			m_pHandles[m_maxHandles - 1].SetNextFree(0);
-		}
-	}
-}       
-
-
-extern int gOverlappingPairs;
-//#include <stdio.h>
-
-template <typename BP_FP_INT_TYPE>
-void	btAxisSweep3Internal<BP_FP_INT_TYPE>::calculateOverlappingPairs(btDispatcher* dispatcher)
-{
-
-	if (m_pairCache->hasDeferredRemoval())
-	{
-	
-		btBroadphasePairArray&	overlappingPairArray = m_pairCache->getOverlappingPairArray();
-
-		//perform a sort, to find duplicates and to sort 'invalid' pairs to the end
-		overlappingPairArray.quickSort(btBroadphasePairSortPredicate());
-
-		overlappingPairArray.resize(overlappingPairArray.size() - m_invalidPair);
-		m_invalidPair = 0;
-
-		
-		int i;
-
-		btBroadphasePair previousPair;
-		previousPair.m_pProxy0 = 0;
-		previousPair.m_pProxy1 = 0;
-		previousPair.m_algorithm = 0;
-		
-		
-		for (i=0;i<overlappingPairArray.size();i++)
-		{
-		
-			btBroadphasePair& pair = overlappingPairArray[i];
-
-			bool isDuplicate = (pair == previousPair);
-
-			previousPair = pair;
-
-			bool needsRemoval = false;
-
-			if (!isDuplicate)
-			{
-				///important to use an AABB test that is consistent with the broadphase
-				bool hasOverlap = testAabbOverlap(pair.m_pProxy0,pair.m_pProxy1);
-
-				if (hasOverlap)
-				{
-					needsRemoval = false;//callback->processOverlap(pair);
-				} else
-				{
-					needsRemoval = true;
-				}
-			} else
-			{
-				//remove duplicate
-				needsRemoval = true;
-				//should have no algorithm
-				btAssert(!pair.m_algorithm);
-			}
-			
-			if (needsRemoval)
-			{
-				m_pairCache->cleanOverlappingPair(pair,dispatcher);
-
-		//		m_overlappingPairArray.swap(i,m_overlappingPairArray.size()-1);
-		//		m_overlappingPairArray.pop_back();
-				pair.m_pProxy0 = 0;
-				pair.m_pProxy1 = 0;
-				m_invalidPair++;
-				gOverlappingPairs--;
-			} 
-			
-		}
-
-	///if you don't like to skip the invalid pairs in the array, execute following code:
-	#define CLEAN_INVALID_PAIRS 1
-	#ifdef CLEAN_INVALID_PAIRS
-
-		//perform a sort, to sort 'invalid' pairs to the end
-		overlappingPairArray.quickSort(btBroadphasePairSortPredicate());
-
-		overlappingPairArray.resize(overlappingPairArray.size() - m_invalidPair);
-		m_invalidPair = 0;
-	#endif//CLEAN_INVALID_PAIRS
-		
-		//printf("overlappingPairArray.size()=%d\n",overlappingPairArray.size());
-	}
-
-}
-
-
-template <typename BP_FP_INT_TYPE>
-bool btAxisSweep3Internal<BP_FP_INT_TYPE>::testAabbOverlap(btBroadphaseProxy* proxy0,btBroadphaseProxy* proxy1)
-{
-	const Handle* pHandleA = static_cast<Handle*>(proxy0);
-	const Handle* pHandleB = static_cast<Handle*>(proxy1);
-	
-	//optimization 1: check the array index (memory address), instead of the m_pos
-
-	for (int axis = 0; axis < 3; axis++)
-	{ 
-		if (pHandleA->m_maxEdges[axis] < pHandleB->m_minEdges[axis] || 
-			pHandleB->m_maxEdges[axis] < pHandleA->m_minEdges[axis]) 
-		{ 
-			return false; 
-		} 
-	} 
-	return true;
-}
-
-template <typename BP_FP_INT_TYPE>
-bool btAxisSweep3Internal<BP_FP_INT_TYPE>::testOverlap2D(const Handle* pHandleA, const Handle* pHandleB,int axis0,int axis1)
-{
-	//optimization 1: check the array index (memory address), instead of the m_pos
-
-	if (pHandleA->m_maxEdges[axis0] < pHandleB->m_minEdges[axis0] || 
-		pHandleB->m_maxEdges[axis0] < pHandleA->m_minEdges[axis0] ||
-		pHandleA->m_maxEdges[axis1] < pHandleB->m_minEdges[axis1] ||
-		pHandleB->m_maxEdges[axis1] < pHandleA->m_minEdges[axis1]) 
-	{ 
-		return false; 
-	} 
-	return true;
-}
-
-template <typename BP_FP_INT_TYPE>
-void btAxisSweep3Internal<BP_FP_INT_TYPE>::updateHandle(BP_FP_INT_TYPE handle, const btVector3& aabbMin,const btVector3& aabbMax,btDispatcher* dispatcher)
-{
-//	btAssert(bounds.IsFinite());
-	//btAssert(bounds.HasVolume());
-
-	Handle* pHandle = getHandle(handle);
-
-	// quantize the new bounds
-	BP_FP_INT_TYPE min[3], max[3];
-	quantize(min, aabbMin, 0);
-	quantize(max, aabbMax, 1);
-
-	// update changed edges
-	for (int axis = 0; axis < 3; axis++)
-	{
-		BP_FP_INT_TYPE emin = pHandle->m_minEdges[axis];
-		BP_FP_INT_TYPE emax = pHandle->m_maxEdges[axis];
-
-		int dmin = (int)min[axis] - (int)m_pEdges[axis][emin].m_pos;
-		int dmax = (int)max[axis] - (int)m_pEdges[axis][emax].m_pos;
-
-		m_pEdges[axis][emin].m_pos = min[axis];
-		m_pEdges[axis][emax].m_pos = max[axis];
-
-		// expand (only adds overlaps)
-		if (dmin < 0)
-			sortMinDown(axis, emin,dispatcher,true);
-
-		if (dmax > 0)
-			sortMaxUp(axis, emax,dispatcher,true);
-
-		// shrink (only removes overlaps)
-		if (dmin > 0)
-			sortMinUp(axis, emin,dispatcher,true);
-
-		if (dmax < 0)
-			sortMaxDown(axis, emax,dispatcher,true);
-
-#ifdef DEBUG_BROADPHASE
-	debugPrintAxis(axis);
-#endif //DEBUG_BROADPHASE
-	}
-
-	
-}
-
-
-
-
-// sorting a min edge downwards can only ever *add* overlaps
-template <typename BP_FP_INT_TYPE>
-void btAxisSweep3Internal<BP_FP_INT_TYPE>::sortMinDown(int axis, BP_FP_INT_TYPE edge, btDispatcher* /* dispatcher */, bool updateOverlaps)
-{
-
-	Edge* pEdge = m_pEdges[axis] + edge;
-	Edge* pPrev = pEdge - 1;
-	Handle* pHandleEdge = getHandle(pEdge->m_handle);
-
-	while (pEdge->m_pos < pPrev->m_pos)
-	{
-		Handle* pHandlePrev = getHandle(pPrev->m_handle);
-
-		if (pPrev->IsMax())
-		{
-			// if previous edge is a maximum check the bounds and add an overlap if necessary
-			const int axis1 = (1  << axis) & 3;
-			const int axis2 = (1  << axis1) & 3;
-			if (updateOverlaps && testOverlap2D(pHandleEdge, pHandlePrev,axis1,axis2))
-			{
-				m_pairCache->addOverlappingPair(pHandleEdge,pHandlePrev);
-				if (m_userPairCallback)
-					m_userPairCallback->addOverlappingPair(pHandleEdge,pHandlePrev);
-
-				//AddOverlap(pEdge->m_handle, pPrev->m_handle);
-
-			}
-
-			// update edge reference in other handle
-			pHandlePrev->m_maxEdges[axis]++;
-		}
-		else
-			pHandlePrev->m_minEdges[axis]++;
-
-		pHandleEdge->m_minEdges[axis]--;
-
-		// swap the edges
-		Edge swap = *pEdge;
-		*pEdge = *pPrev;
-		*pPrev = swap;
-
-		// decrement
-		pEdge--;
-		pPrev--;
-	}
-
-#ifdef DEBUG_BROADPHASE
-	debugPrintAxis(axis);
-#endif //DEBUG_BROADPHASE
-
-}
-
-// sorting a min edge upwards can only ever *remove* overlaps
-template <typename BP_FP_INT_TYPE>
-void btAxisSweep3Internal<BP_FP_INT_TYPE>::sortMinUp(int axis, BP_FP_INT_TYPE edge, btDispatcher* dispatcher, bool updateOverlaps)
-{
-	Edge* pEdge = m_pEdges[axis] + edge;
-	Edge* pNext = pEdge + 1;
-	Handle* pHandleEdge = getHandle(pEdge->m_handle);
-
-	while (pNext->m_handle && (pEdge->m_pos >= pNext->m_pos))
-	{
-		Handle* pHandleNext = getHandle(pNext->m_handle);
-
-		if (pNext->IsMax())
-		{
-			Handle* handle0 = getHandle(pEdge->m_handle);
-			Handle* handle1 = getHandle(pNext->m_handle);
-			const int axis1 = (1  << axis) & 3;
-			const int axis2 = (1  << axis1) & 3;
-			
-			// if next edge is maximum remove any overlap between the two handles
-			if (updateOverlaps 
-#ifdef USE_OVERLAP_TEST_ON_REMOVES
-				&& testOverlap2D(handle0,handle1,axis1,axis2)
-#endif //USE_OVERLAP_TEST_ON_REMOVES
-				)
-			{
-				
-
-				m_pairCache->removeOverlappingPair(handle0,handle1,dispatcher);	
-				if (m_userPairCallback)
-					m_userPairCallback->removeOverlappingPair(handle0,handle1,dispatcher);
-				
-			}
-
-
-			// update edge reference in other handle
-			pHandleNext->m_maxEdges[axis]--;
-		}
-		else
-			pHandleNext->m_minEdges[axis]--;
-
-		pHandleEdge->m_minEdges[axis]++;
-
-		// swap the edges
-		Edge swap = *pEdge;
-		*pEdge = *pNext;
-		*pNext = swap;
-
-		// increment
-		pEdge++;
-		pNext++;
-	}
-
-
-}
-
-// sorting a max edge downwards can only ever *remove* overlaps
-template <typename BP_FP_INT_TYPE>
-void btAxisSweep3Internal<BP_FP_INT_TYPE>::sortMaxDown(int axis, BP_FP_INT_TYPE edge, btDispatcher* dispatcher, bool updateOverlaps)
-{
-
-	Edge* pEdge = m_pEdges[axis] + edge;
-	Edge* pPrev = pEdge - 1;
-	Handle* pHandleEdge = getHandle(pEdge->m_handle);
-
-	while (pEdge->m_pos < pPrev->m_pos)
-	{
-		Handle* pHandlePrev = getHandle(pPrev->m_handle);
-
-		if (!pPrev->IsMax())
-		{
-			// if previous edge was a minimum remove any overlap between the two handles
-			Handle* handle0 = getHandle(pEdge->m_handle);
-			Handle* handle1 = getHandle(pPrev->m_handle);
-			const int axis1 = (1  << axis) & 3;
-			const int axis2 = (1  << axis1) & 3;
-
-			if (updateOverlaps  
-#ifdef USE_OVERLAP_TEST_ON_REMOVES
-				&& testOverlap2D(handle0,handle1,axis1,axis2)
-#endif //USE_OVERLAP_TEST_ON_REMOVES
-				)
-			{
-				//this is done during the overlappingpairarray iteration/narrowphase collision
-
-				
-				m_pairCache->removeOverlappingPair(handle0,handle1,dispatcher);
-				if (m_userPairCallback)
-					m_userPairCallback->removeOverlappingPair(handle0,handle1,dispatcher);
-			
-
-
-			}
-
-			// update edge reference in other handle
-			pHandlePrev->m_minEdges[axis]++;;
-		}
-		else
-			pHandlePrev->m_maxEdges[axis]++;
-
-		pHandleEdge->m_maxEdges[axis]--;
-
-		// swap the edges
-		Edge swap = *pEdge;
-		*pEdge = *pPrev;
-		*pPrev = swap;
-
-		// decrement
-		pEdge--;
-		pPrev--;
-	}
-
-	
-#ifdef DEBUG_BROADPHASE
-	debugPrintAxis(axis);
-#endif //DEBUG_BROADPHASE
-
-}
-
-// sorting a max edge upwards can only ever *add* overlaps
-template <typename BP_FP_INT_TYPE>
-void btAxisSweep3Internal<BP_FP_INT_TYPE>::sortMaxUp(int axis, BP_FP_INT_TYPE edge, btDispatcher* /* dispatcher */, bool updateOverlaps)
-{
-	Edge* pEdge = m_pEdges[axis] + edge;
-	Edge* pNext = pEdge + 1;
-	Handle* pHandleEdge = getHandle(pEdge->m_handle);
-
-	while (pNext->m_handle && (pEdge->m_pos >= pNext->m_pos))
-	{
-		Handle* pHandleNext = getHandle(pNext->m_handle);
-
-		const int axis1 = (1  << axis) & 3;
-		const int axis2 = (1  << axis1) & 3;
-
-		if (!pNext->IsMax())
-		{
-			// if next edge is a minimum check the bounds and add an overlap if necessary
-			if (updateOverlaps && testOverlap2D(pHandleEdge, pHandleNext,axis1,axis2))
-			{
-				Handle* handle0 = getHandle(pEdge->m_handle);
-				Handle* handle1 = getHandle(pNext->m_handle);
-				m_pairCache->addOverlappingPair(handle0,handle1);
-				if (m_userPairCallback)
-					m_userPairCallback->addOverlappingPair(handle0,handle1);
-			}
-
-			// update edge reference in other handle
-			pHandleNext->m_minEdges[axis]--;
-		}
-		else
-			pHandleNext->m_maxEdges[axis]--;
-
-		pHandleEdge->m_maxEdges[axis]++;
-
-		// swap the edges
-		Edge swap = *pEdge;
-		*pEdge = *pNext;
-		*pNext = swap;
-
-		// increment
-		pEdge++;
-		pNext++;
-	}
-	
-}
-
-
-
-////////////////////////////////////////////////////////////////////
-
+#include "btAxisSweep3Internal.h"
 
 /// The btAxisSweep3 is an efficient implementation of the 3d axis sweep and prune broadphase.
 /// It uses arrays rather then lists for storage of the 3 axis. Also it operates using 16 bit integer coordinates instead of floats.
@@ -1047,4 +50,3 @@ public:
 };
 
 #endif
-
diff --git a/bullet/BulletCollision/BroadphaseCollision/btBroadphaseInterface.h b/bullet/BulletCollision/BroadphaseCollision/btBroadphaseInterface.h
index d31b77f..fb68e00 100644
--- a/bullet/BulletCollision/BroadphaseCollision/btBroadphaseInterface.h
+++ b/bullet/BulletCollision/BroadphaseCollision/btBroadphaseInterface.h
@@ -41,6 +41,10 @@ struct	btBroadphaseRayCallback : public btBroadphaseAabbCallback
 	btScalar		m_lambda_max;
 
 	virtual ~btBroadphaseRayCallback() {}
+	
+protected:
+    
+    btBroadphaseRayCallback() {}
 };
 
 #include "LinearMath/btVector3.h"
diff --git a/bullet/BulletCollision/BroadphaseCollision/btOverlappingPairCallback.h b/bullet/BulletCollision/BroadphaseCollision/btOverlappingPairCallback.h
index 9c7b6f8..3e069fa 100644
--- a/bullet/BulletCollision/BroadphaseCollision/btOverlappingPairCallback.h
+++ b/bullet/BulletCollision/BroadphaseCollision/btOverlappingPairCallback.h
@@ -23,6 +23,9 @@ struct  btBroadphasePair;
 ///The btOverlappingPairCallback class is an additional optional broadphase user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
 class btOverlappingPairCallback
 {
+protected:
+    btOverlappingPairCallback() {}
+    
 public:
 	virtual ~btOverlappingPairCallback()
 	{
diff --git a/bullet/BulletCollision/CMakeLists.txt b/bullet/BulletCollision/CMakeLists.txt
index 7c8d0e8..77a96f9 100644
--- a/bullet/BulletCollision/CMakeLists.txt
+++ b/bullet/BulletCollision/CMakeLists.txt
@@ -102,6 +102,7 @@ SET(Root_HDRS
 	../btBulletCollisionCommon.h
 )
 SET(BroadphaseCollision_HDRS
+    BroadphaseCollision/btAxisSweep3Internal.h
 	BroadphaseCollision/btAxisSweep3.h
 	BroadphaseCollision/btBroadphaseInterface.h
 	BroadphaseCollision/btBroadphaseProxy.h
@@ -189,12 +190,15 @@ SET(CollisionShapes_HDRS
 SET(Gimpact_HDRS
 	Gimpact/btBoxCollision.h
 	Gimpact/btClipPolygon.h
+	Gimpact/btContactProcessingSructs.h
 	Gimpact/btContactProcessing.h
 	Gimpact/btGenericPoolAllocator.h
 	Gimpact/btGeometryOperations.h
+	Gimpact/btGImpactBvhSructs.h
 	Gimpact/btGImpactBvh.h
 	Gimpact/btGImpactCollisionAlgorithm.h
 	Gimpact/btGImpactMassUtil.h
+	Gimpact/btGImpactQuantizedBvhSructs.h
 	Gimpact/btGImpactQuantizedBvh.h
 	Gimpact/btGImpactShape.h
 	Gimpact/btQuantization.h
diff --git a/bullet/BulletCollision/CollisionDispatch/btActivatingCollisionAlgorithm.h b/bullet/BulletCollision/CollisionDispatch/btActivatingCollisionAlgorithm.h
index 489812b..0e19f1e 100644
--- a/bullet/BulletCollision/CollisionDispatch/btActivatingCollisionAlgorithm.h
+++ b/bullet/BulletCollision/CollisionDispatch/btActivatingCollisionAlgorithm.h
@@ -24,12 +24,13 @@ class btActivatingCollisionAlgorithm : public btCollisionAlgorithm
 //	btCollisionObject* m_colObj0;
 //	btCollisionObject* m_colObj1;
 
-public:
+protected:
 
 	btActivatingCollisionAlgorithm (const btCollisionAlgorithmConstructionInfo& ci);
 
 	btActivatingCollisionAlgorithm (const btCollisionAlgorithmConstructionInfo& ci, const btCollisionObjectWrapper* body0Wrap,const btCollisionObjectWrapper* body1Wrap);
 
+public:
 	virtual ~btActivatingCollisionAlgorithm();
 
 };
diff --git a/bullet/BulletCollision/CollisionDispatch/btCollisionWorldImporter.h b/bullet/BulletCollision/CollisionDispatch/btCollisionWorldImporter.h
index 9a6d16f..ecb7a8a 100644
--- a/bullet/BulletCollision/CollisionDispatch/btCollisionWorldImporter.h
+++ b/bullet/BulletCollision/CollisionDispatch/btCollisionWorldImporter.h
@@ -124,7 +124,7 @@ public:
 	btCollisionShape* getCollisionShapeByIndex(int index);
 	int getNumRigidBodies() const;
 	btCollisionObject* getRigidBodyByIndex(int index) const;
-	int getNumConstraints() const;
+	//int getNumConstraints() const;
 
 	int getNumBvhs() const;
 	btOptimizedBvh*  getBvhByIndex(int index) const;
diff --git a/bullet/BulletCollision/CollisionDispatch/btCompoundCompoundCollisionAlgorithm.h b/bullet/BulletCollision/CollisionDispatch/btCompoundCompoundCollisionAlgorithm.h
index 06a762f..f29f7a7 100644
--- a/bullet/BulletCollision/CollisionDispatch/btCompoundCompoundCollisionAlgorithm.h
+++ b/bullet/BulletCollision/CollisionDispatch/btCompoundCompoundCollisionAlgorithm.h
@@ -33,8 +33,6 @@ class btDispatcher;
 class btCollisionObject;
 
 class btCollisionShape;
-typedef bool (*btShapePairCallback)(const btCollisionShape* pShape0, const btCollisionShape* pShape1);
-extern btShapePairCallback gCompoundCompoundChildShapePairCallback;
 
 /// btCompoundCompoundCollisionAlgorithm  supports collision between two btCompoundCollisionShape shapes
 class btCompoundCompoundCollisionAlgorithm  : public btCompoundCollisionAlgorithm
diff --git a/bullet/BulletCollision/CollisionDispatch/btManifoldResult.cpp b/bullet/BulletCollision/CollisionDispatch/btManifoldResult.cpp
index be8e51d..c1041e2 100644
--- a/bullet/BulletCollision/CollisionDispatch/btManifoldResult.cpp
+++ b/bullet/BulletCollision/CollisionDispatch/btManifoldResult.cpp
@@ -111,6 +111,7 @@ void btManifoldResult::addContactPoint(const btVector3& normalOnBInWorld,const b
 		return;
 
 	bool isSwapped = m_manifoldPtr->getBody0() != m_body0Wrap->getCollisionObject();
+	bool isNewCollision = m_manifoldPtr->getNumContacts() == 0;
 
 	btVector3 pointA = pointInWorld + normalOnBInWorld * depth;
 
@@ -187,5 +188,9 @@ void btManifoldResult::addContactPoint(const btVector3& normalOnBInWorld,const b
 		(*gContactAddedCallback)(m_manifoldPtr->getContactPoint(insertIndex),obj0Wrap,newPt.m_partId0,newPt.m_index0,obj1Wrap,newPt.m_partId1,newPt.m_index1);
 	}
 
+	if (gContactStartedCallback && isNewCollision)
+	{
+		gContactStartedCallback(m_manifoldPtr);
+	}
 }
 
diff --git a/bullet/BulletCollision/CollisionShapes/btPolyhedralConvexShape.h b/bullet/BulletCollision/CollisionShapes/btPolyhedralConvexShape.h
index 961d001..7bf8e01 100644
--- a/bullet/BulletCollision/CollisionShapes/btPolyhedralConvexShape.h
+++ b/bullet/BulletCollision/CollisionShapes/btPolyhedralConvexShape.h
@@ -93,10 +93,12 @@ protected:
 		aabbMax = m_localAabbMax;
 	}
 
-public:
+protected:
 
 	btPolyhedralConvexAabbCachingShape();
 	
+public:
+	
 	inline void getNonvirtualAabb(const btTransform& trans,btVector3& aabbMin,btVector3& aabbMax, btScalar margin) const
 	{
 
diff --git a/bullet/BulletCollision/Gimpact/btBoxCollision.h b/bullet/BulletCollision/Gimpact/btBoxCollision.h
index 0a0357e..2fa1fb0 100644
--- a/bullet/BulletCollision/Gimpact/btBoxCollision.h
+++ b/bullet/BulletCollision/Gimpact/btBoxCollision.h
@@ -234,7 +234,24 @@ public:
 
 	btAABB()
 	{}
-
+	
+	bool operator<(const btAABB& obj) const {
+        return
+            m_min < obj.m_min &&
+            m_max < obj.m_max;
+    }
+    
+    bool operator>(const btAABB& obj) const {
+        return
+            m_min > obj.m_min &&
+            m_max > obj.m_max;
+    }
+    
+    bool operator==(const btAABB& obj) const {
+        return
+            m_min == obj.m_min &&
+            m_max == obj.m_max;
+    }
 
 	btAABB(const btVector3 & V1,
 			 const btVector3 & V2,
diff --git a/bullet/BulletCollision/Gimpact/btContactProcessing.h b/bullet/BulletCollision/Gimpact/btContactProcessing.h
index 0c66f8e..7b00e60 100644
--- a/bullet/BulletCollision/Gimpact/btContactProcessing.h
+++ b/bullet/BulletCollision/Gimpact/btContactProcessing.h
@@ -27,86 +27,7 @@ subject to the following restrictions:
 #include "LinearMath/btTransform.h"
 #include "LinearMath/btAlignedObjectArray.h"
 #include "btTriangleShapeEx.h"
-
-
-
-/**
-Configuration var for applying interpolation of  contact normals
-*/
-#define NORMAL_CONTACT_AVERAGE 1
-
-#define CONTACT_DIFF_EPSILON 0.00001f
-
-///The GIM_CONTACT is an internal GIMPACT structure, similar to btManifoldPoint.
-///@todo: remove and replace GIM_CONTACT by btManifoldPoint.
-class GIM_CONTACT
-{
-public:
-    btVector3 m_point;
-    btVector3 m_normal;
-    btScalar m_depth;//Positive value indicates interpenetration
-    btScalar m_distance;//Padding not for use
-    int m_feature1;//Face number
-    int m_feature2;//Face number
-public:
-    GIM_CONTACT()
-    {
-    }
-
-    GIM_CONTACT(const GIM_CONTACT & contact):
-				m_point(contact.m_point),
-				m_normal(contact.m_normal),
-				m_depth(contact.m_depth),
-				m_feature1(contact.m_feature1),
-				m_feature2(contact.m_feature2)
-    {
-    }
-
-    GIM_CONTACT(const btVector3 &point,const btVector3 & normal,
-    	 			btScalar depth, int feature1, int feature2):
-				m_point(point),
-				m_normal(normal),
-				m_depth(depth),
-				m_feature1(feature1),
-				m_feature2(feature2)
-    {
-    }
-
-	//! Calcs key for coord classification
-    SIMD_FORCE_INLINE unsigned int calc_key_contact() const
-    {
-    	int _coords[] = {
-    		(int)(m_point[0]*1000.0f+1.0f),
-    		(int)(m_point[1]*1333.0f),
-    		(int)(m_point[2]*2133.0f+3.0f)};
-		unsigned int _hash=0;
-		unsigned int *_uitmp = (unsigned int *)(&_coords[0]);
-		_hash = *_uitmp;
-		_uitmp++;
-		_hash += (*_uitmp)<<4;
-		_uitmp++;
-		_hash += (*_uitmp)<<8;
-		return _hash;
-    }
-
-    SIMD_FORCE_INLINE void interpolate_normals( btVector3 * normals,int normal_count)
-    {
-    	btVector3 vec_sum(m_normal);
-		for(int i=0;i<normal_count;i++)
-		{
-			vec_sum += normals[i];
-		}
-
-		btScalar vec_sum_len = vec_sum.length2();
-		if(vec_sum_len <CONTACT_DIFF_EPSILON) return;
-
-		//GIM_INV_SQRT(vec_sum_len,vec_sum_len); // 1/sqrt(vec_sum_len)
-
-		m_normal = vec_sum/btSqrt(vec_sum_len);
-    }
-
-};
-
+#include "btContactProcessingSructs.h"
 
 class btContactArray:public btAlignedObjectArray<GIM_CONTACT>
 {
@@ -141,5 +62,4 @@ public:
 	void merge_contacts_unique(const btContactArray & contacts);
 };
 
-
 #endif // GIM_CONTACT_H_INCLUDED
diff --git a/bullet/BulletCollision/Gimpact/btGImpactBvh.h b/bullet/BulletCollision/Gimpact/btGImpactBvh.h
index 6174ae9..88a87cd 100644
--- a/bullet/BulletCollision/Gimpact/btGImpactBvh.h
+++ b/bullet/BulletCollision/Gimpact/btGImpactBvh.h
@@ -29,31 +29,7 @@ subject to the following restrictions:
 
 #include "btBoxCollision.h"
 #include "btTriangleShapeEx.h"
-
-
-
-
-
-//! Overlapping pair
-struct GIM_PAIR
-{
-    int m_index1;
-    int m_index2;
-    GIM_PAIR()
-    {}
-
-    GIM_PAIR(const GIM_PAIR & p)
-    {
-    	m_index1 = p.m_index1;
-    	m_index2 = p.m_index2;
-	}
-
-	GIM_PAIR(int index1, int index2)
-    {
-    	m_index1 = index1;
-    	m_index2 = index2;
-	}
-};
+#include "btGImpactBvhSructs.h"
 
 //! A pairset array
 class btPairSet: public btAlignedObjectArray<GIM_PAIR>
@@ -74,59 +50,6 @@ public:
 	}
 };
 
-
-///GIM_BVH_DATA is an internal GIMPACT collision structure to contain axis aligned bounding box
-struct GIM_BVH_DATA
-{
-	btAABB m_bound;
-	int m_data;
-};
-
-//! Node Structure for trees
-class GIM_BVH_TREE_NODE
-{
-public:
-	btAABB m_bound;
-protected:
-	int	m_escapeIndexOrDataIndex;
-public:
-	GIM_BVH_TREE_NODE()
-	{
-		m_escapeIndexOrDataIndex = 0;
-	}
-
-	SIMD_FORCE_INLINE bool isLeafNode() const
-	{
-		//skipindex is negative (internal node), triangleindex >=0 (leafnode)
-		return (m_escapeIndexOrDataIndex>=0);
-	}
-
-	SIMD_FORCE_INLINE int getEscapeIndex() const
-	{
-		//btAssert(m_escapeIndexOrDataIndex < 0);
-		return -m_escapeIndexOrDataIndex;
-	}
-
-	SIMD_FORCE_INLINE void setEscapeIndex(int index)
-	{
-		m_escapeIndexOrDataIndex = -index;
-	}
-
-	SIMD_FORCE_INLINE int getDataIndex() const
-	{
-		//btAssert(m_escapeIndexOrDataIndex >= 0);
-
-		return m_escapeIndexOrDataIndex;
-	}
-
-	SIMD_FORCE_INLINE void setDataIndex(int index)
-	{
-		m_escapeIndexOrDataIndex = index;
-	}
-
-};
-
-
 class GIM_BVH_DATA_ARRAY:public btAlignedObjectArray<GIM_BVH_DATA>
 {
 };
@@ -392,5 +315,4 @@ public:
 		btPairSet & collision_pairs);
 };
 
-
 #endif // GIM_BOXPRUNING_H_INCLUDED
diff --git a/bullet/BulletCollision/Gimpact/btGImpactQuantizedBvh.h b/bullet/BulletCollision/Gimpact/btGImpactQuantizedBvh.h
index e6e52ff..10be905 100644
--- a/bullet/BulletCollision/Gimpact/btGImpactQuantizedBvh.h
+++ b/bullet/BulletCollision/Gimpact/btGImpactQuantizedBvh.h
@@ -26,73 +26,7 @@ subject to the following restrictions:
 
 #include "btGImpactBvh.h"
 #include "btQuantization.h"
-
-
-
-
-
-///btQuantizedBvhNode is a compressed aabb node, 16 bytes.
-///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).
-ATTRIBUTE_ALIGNED16	(struct) BT_QUANTIZED_BVH_NODE
-{
-	//12 bytes
-	unsigned short int	m_quantizedAabbMin[3];
-	unsigned short int	m_quantizedAabbMax[3];
-	//4 bytes
-	int	m_escapeIndexOrDataIndex;
-
-	BT_QUANTIZED_BVH_NODE()
-	{
-		m_escapeIndexOrDataIndex = 0;
-	}
-
-	SIMD_FORCE_INLINE bool isLeafNode() const
-	{
-		//skipindex is negative (internal node), triangleindex >=0 (leafnode)
-		return (m_escapeIndexOrDataIndex>=0);
-	}
-
-	SIMD_FORCE_INLINE int getEscapeIndex() const
-	{
-		//btAssert(m_escapeIndexOrDataIndex < 0);
-		return -m_escapeIndexOrDataIndex;
-	}
-
-	SIMD_FORCE_INLINE void setEscapeIndex(int index)
-	{
-		m_escapeIndexOrDataIndex = -index;
-	}
-
-	SIMD_FORCE_INLINE int getDataIndex() const
-	{
-		//btAssert(m_escapeIndexOrDataIndex >= 0);
-
-		return m_escapeIndexOrDataIndex;
-	}
-
-	SIMD_FORCE_INLINE void setDataIndex(int index)
-	{
-		m_escapeIndexOrDataIndex = index;
-	}
-
-	SIMD_FORCE_INLINE bool testQuantizedBoxOverlapp(
-		unsigned short * quantizedMin,unsigned short * quantizedMax) const
-	{
-		if(m_quantizedAabbMin[0] > quantizedMax[0] ||
-		   m_quantizedAabbMax[0] < quantizedMin[0] ||
-		   m_quantizedAabbMin[1] > quantizedMax[1] ||
-		   m_quantizedAabbMax[1] < quantizedMin[1] ||
-		   m_quantizedAabbMin[2] > quantizedMax[2] ||
-		   m_quantizedAabbMax[2] < quantizedMin[2])
-		{
-			return false;
-		}
-		return true;
-	}
-
-};
-
-
+#include "btGImpactQuantizedBvhSructs.h"
 
 class GIM_QUANTIZED_BVH_NODE_ARRAY:public btAlignedObjectArray<BT_QUANTIZED_BVH_NODE>
 {
@@ -368,5 +302,4 @@ public:
 		btPairSet & collision_pairs);
 };
 
-
 #endif // GIM_BOXPRUNING_H_INCLUDED
diff --git a/bullet/BulletCollision/Gimpact/gim_array.h b/bullet/BulletCollision/Gimpact/gim_array.h
index 27e6f32..cda51a5 100644
--- a/bullet/BulletCollision/Gimpact/gim_array.h
+++ b/bullet/BulletCollision/Gimpact/gim_array.h
@@ -228,7 +228,7 @@ public:
 	inline void push_back_memcpy(const T & obj)
 	{
 	    this->growingCheck();
-	    irr_simd_memcpy(&m_data[m_size],&obj,sizeof(T));
+	    gim_simd_memcpy(&m_data[m_size],&obj,sizeof(T));
 	    m_size++;
 	}
 
diff --git a/bullet/BulletCollision/Gimpact/gim_basic_geometry_operations.h b/bullet/BulletCollision/Gimpact/gim_basic_geometry_operations.h
index d98051d..0c48cb6 100644
--- a/bullet/BulletCollision/Gimpact/gim_basic_geometry_operations.h
+++ b/bullet/BulletCollision/Gimpact/gim_basic_geometry_operations.h
@@ -41,10 +41,13 @@ email: projectileman@yahoo.com
 
 
 
-
+#ifndef PLANEDIREPSILON
 #define PLANEDIREPSILON 0.0000001f
-#define PARALELENORMALS 0.000001f
+#endif
 
+#ifndef PARALELENORMALS
+#define PARALELENORMALS 0.000001f
+#endif
 
 #define TRIANGLE_NORMAL(v1,v2,v3,n)\
 {\
diff --git a/bullet/BulletCollision/Gimpact/gim_box_collision.h b/bullet/BulletCollision/Gimpact/gim_box_collision.h
index 9c57263..a051b4f 100644
--- a/bullet/BulletCollision/Gimpact/gim_box_collision.h
+++ b/bullet/BulletCollision/Gimpact/gim_box_collision.h
@@ -97,6 +97,8 @@ email: projectileman@yahoo.com
 //	return test_cross_edge_box(edge,absolute_edge,pointa,pointb,extend,1,0,0,1);
 //}
 
+#ifndef TEST_CROSS_EDGE_BOX_MCR
+
 #define TEST_CROSS_EDGE_BOX_MCR(edge,absolute_edge,pointa,pointb,_extend,i_dir_0,i_dir_1,i_comp_0,i_comp_1)\
 {\
 	const btScalar dir0 = -edge[i_dir_0];\
@@ -113,6 +115,7 @@ email: projectileman@yahoo.com
 	if(pmin>rad || -rad>pmax) return false;\
 }\
 
+#endif
 
 #define TEST_CROSS_EDGE_BOX_X_AXIS_MCR(edge,absolute_edge,pointa,pointb,_extend)\
 {\
@@ -190,8 +193,9 @@ public:
 	}
 };
 
-
+#ifndef BOX_PLANE_EPSILON
 #define BOX_PLANE_EPSILON 0.000001f
+#endif
 
 //! Axis aligned box
 class GIM_AABB
@@ -571,7 +575,7 @@ public:
 	}
 };
 
-
+#ifndef BT_BOX_COLLISION_H_INCLUDED
 //! Compairison of transformation objects
 SIMD_FORCE_INLINE bool btCompareTransformsEqual(const btTransform & t1,const btTransform & t2)
 {
@@ -582,6 +586,7 @@ SIMD_FORCE_INLINE bool btCompareTransformsEqual(const btTransform & t1,const btT
 	if(!(t1.getBasis().getRow(2) == t2.getBasis().getRow(2)) ) return false;
 	return true;
 }
+#endif
 
 
 
diff --git a/bullet/BulletCollision/Gimpact/gim_contact.h b/bullet/BulletCollision/Gimpact/gim_contact.h
index 5d9f8ef..b41c714 100644
--- a/bullet/BulletCollision/Gimpact/gim_contact.h
+++ b/bullet/BulletCollision/Gimpact/gim_contact.h
@@ -40,8 +40,15 @@ email: projectileman@yahoo.com
 /**
 Configuration var for applying interpolation of  contact normals
 */
+#ifndef NORMAL_CONTACT_AVERAGE
 #define NORMAL_CONTACT_AVERAGE 1
+#endif
+
+#ifndef CONTACT_DIFF_EPSILON
 #define CONTACT_DIFF_EPSILON 0.00001f
+#endif
+
+#ifndef BT_CONTACT_H_STRUCTS_INCLUDED
 
 /// Structure for collision results
 ///Functions for managing and sorting contacts resulting from a collision query.
@@ -121,6 +128,7 @@ public:
 
 };
 
+#endif
 
 class gim_contact_array:public gim_array<GIM_CONTACT>
 {
diff --git a/bullet/BulletCollision/Gimpact/gim_tri_collision.h b/bullet/BulletCollision/Gimpact/gim_tri_collision.h
index 5b552a1..267f806 100644
--- a/bullet/BulletCollision/Gimpact/gim_tri_collision.h
+++ b/bullet/BulletCollision/Gimpact/gim_tri_collision.h
@@ -38,8 +38,9 @@ email: projectileman@yahoo.com
 
 
 
-
+#ifndef MAX_TRI_CLIPPING
 #define MAX_TRI_CLIPPING 16
+#endif
 
 //! Structure for collision
 struct GIM_TRIANGLE_CONTACT_DATA
diff --git a/bullet/BulletCollision/NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h b/bullet/BulletCollision/NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h
index 46ce1ab..0ea7b48 100644
--- a/bullet/BulletCollision/NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h
+++ b/bullet/BulletCollision/NarrowPhaseCollision/btDiscreteCollisionDetectorInterface.h
@@ -67,10 +67,12 @@ struct btStorageResult : public btDiscreteCollisionDetectorInterface::Result
 		btVector3	m_closestPointInB;
 		btScalar	m_distance; //negative means penetration !
 
+    protected:
 		btStorageResult() : m_distance(btScalar(BT_LARGE_FLOAT))
 		{
-
 		}
+		
+	public:
 		virtual ~btStorageResult() {};
 
 		virtual void addContactPoint(const btVector3& normalOnBInWorld,const btVector3& pointInWorld,btScalar depth)
diff --git a/bullet/BulletCollision/NarrowPhaseCollision/btPersistentManifold.cpp b/bullet/BulletCollision/NarrowPhaseCollision/btPersistentManifold.cpp
index 4d92e85..7964735 100644
--- a/bullet/BulletCollision/NarrowPhaseCollision/btPersistentManifold.cpp
+++ b/bullet/BulletCollision/NarrowPhaseCollision/btPersistentManifold.cpp
@@ -21,6 +21,8 @@ subject to the following restrictions:
 btScalar					gContactBreakingThreshold = btScalar(0.02);
 ContactDestroyedCallback	gContactDestroyedCallback = 0;
 ContactProcessedCallback	gContactProcessedCallback = 0;
+ContactStartedCallback		gContactStartedCallback = 0;
+ContactEndedCallback		gContactEndedCallback = 0;
 ///gContactCalcArea3Points will approximate the convex hull area using 3 points
 ///when setting it to false, it will use 4 points to compute the area: it is more accurate but slower
 bool						gContactCalcArea3Points = true;
diff --git a/bullet/BulletCollision/NarrowPhaseCollision/btPersistentManifold.h b/bullet/BulletCollision/NarrowPhaseCollision/btPersistentManifold.h
index 3b82be1..e971721 100644
--- a/bullet/BulletCollision/NarrowPhaseCollision/btPersistentManifold.h
+++ b/bullet/BulletCollision/NarrowPhaseCollision/btPersistentManifold.h
@@ -28,10 +28,18 @@ struct btCollisionResult;
 ///maximum contact breaking and merging threshold
 extern btScalar gContactBreakingThreshold;
 
+#ifndef SWIG
+class btPersistentManifold;
+
 typedef bool (*ContactDestroyedCallback)(void* userPersistentData);
 typedef bool (*ContactProcessedCallback)(btManifoldPoint& cp,void* body0,void* body1);
+typedef void (*ContactStartedCallback)(btPersistentManifold* const &manifold);
+typedef void (*ContactEndedCallback)(btPersistentManifold* const &manifold);
 extern ContactDestroyedCallback	gContactDestroyedCallback;
 extern ContactProcessedCallback gContactProcessedCallback;
+extern ContactStartedCallback gContactStartedCallback;
+extern ContactEndedCallback gContactEndedCallback;
+#endif //SWIG
 
 //the enum starts at 1024 to avoid type conflicts with btTypedConstraint
 enum btContactManifoldTypes
@@ -171,6 +179,11 @@ public:
 
 		btAssert(m_pointCache[lastUsedIndex].m_userPersistentData==0);
 		m_cachedPoints--;
+
+		if (gContactEndedCallback && m_cachedPoints == 0)
+		{
+			gContactEndedCallback(this);
+		}
 	}
 	void replaceContactPoint(const btManifoldPoint& newPoint,int insertIndex)
 	{
@@ -220,6 +233,11 @@ public:
 		{
 			clearUserCache(m_pointCache[i]);
 		}
+
+		if (gContactEndedCallback && m_cachedPoints)
+		{
+			gContactEndedCallback(this);
+		}
 		m_cachedPoints = 0;
 	}
 
diff --git a/bullet/BulletDynamics/ConstraintSolver/btContactConstraint.h b/bullet/BulletDynamics/ConstraintSolver/btContactConstraint.h
index 477c79d..adb2268 100644
--- a/bullet/BulletDynamics/ConstraintSolver/btContactConstraint.h
+++ b/bullet/BulletDynamics/ConstraintSolver/btContactConstraint.h
@@ -28,11 +28,13 @@ protected:
 
 	btPersistentManifold m_contactManifold;
 
-public:
+protected:
 
 
 	btContactConstraint(btPersistentManifold* contactManifold,btRigidBody& rbA,btRigidBody& rbB);
 
+public:
+
 	void	setContactManifold(btPersistentManifold* contactManifold);
 
 	btPersistentManifold* getContactManifold()
diff --git a/bullet/BulletDynamics/Vehicle/btRaycastVehicle.h b/bullet/BulletDynamics/Vehicle/btRaycastVehicle.h
index 82d44c7..04656b9 100644
--- a/bullet/BulletDynamics/Vehicle/btRaycastVehicle.h
+++ b/bullet/BulletDynamics/Vehicle/btRaycastVehicle.h
@@ -19,7 +19,7 @@ class btDynamicsWorld;
 #include "btWheelInfo.h"
 #include "BulletDynamics/Dynamics/btActionInterface.h"
 
-class btVehicleTuning;
+//class btVehicleTuning;
 
 ///rayCast vehicle, very special constraint that turn a rigidbody into a vehicle.
 class btRaycastVehicle : public btActionInterface
diff --git a/bullet/BulletDynamics/Vehicle/btWheelInfo.h b/bullet/BulletDynamics/Vehicle/btWheelInfo.h
index f916053..f991a57 100644
--- a/bullet/BulletDynamics/Vehicle/btWheelInfo.h
+++ b/bullet/BulletDynamics/Vehicle/btWheelInfo.h
@@ -79,6 +79,8 @@ struct btWheelInfo
 	
 	void*		m_clientInfo;//can be used to store pointer to sync transforms...
 
+	btWheelInfo() {}
+
 	btWheelInfo(btWheelInfoConstructionInfo& ci)
 
 	{
diff --git a/bullet/BulletInverseDynamics/IDConfig.hpp b/bullet/BulletInverseDynamics/IDConfig.hpp
index 08bbdcb..188066a 100644
--- a/bullet/BulletInverseDynamics/IDConfig.hpp
+++ b/bullet/BulletInverseDynamics/IDConfig.hpp
@@ -69,16 +69,16 @@ typedef btScalar idScalar;
 #define BT_ID_USE_DOUBLE_PRECISION
 #endif
 // use bullet types for arrays and array indices
-#include "Bullet3Common/b3AlignedObjectArray.h"
+#include "LinearMath/btAlignedObjectArray.h"
 // this is to make it work with C++2003, otherwise we could do this:
 // template <typename T>
 // using idArray = b3AlignedObjectArray<T>;
 template <typename T>
 struct idArray {
-	typedef b3AlignedObjectArray<T> type;
+	typedef btAlignedObjectArray<T> type;
 };
 typedef int idArrayIdx;
-#define ID_DECLARE_ALIGNED_ALLOCATOR B3_DECLARE_ALIGNED_ALLOCATOR
+#define ID_DECLARE_ALIGNED_ALLOCATOR() BT_DECLARE_ALIGNED_ALLOCATOR()
 
 // use bullet's allocator functions
 #define idMalloc btAllocFunc
diff --git a/bullet/BulletInverseDynamics/IDConfigBuiltin.hpp b/bullet/BulletInverseDynamics/IDConfigBuiltin.hpp
deleted file mode 100644
index 130c19c..0000000
--- a/bullet/BulletInverseDynamics/IDConfigBuiltin.hpp
+++ /dev/null
@@ -1,37 +0,0 @@
-///@file Configuration for Inverse Dynamics Library without external dependencies
-#ifndef INVDYNCONFIG_BUILTIN_HPP_
-#define INVDYNCONFIG_BUILTIN_HPP_
-#define btInverseDynamics btInverseDynamicsBuiltin
-#ifdef BT_USE_DOUBLE_PRECISION
-// choose double/single precision version
-typedef double idScalar;
-#else
-typedef float idScalar;
-#endif
-// use std::vector for arrays
-#include <vector>
-// this is to make it work with C++2003, otherwise we could do this
-// template <typename T>
-// using idArray = std::vector<T>;
-template <typename T>
-struct idArray {
-	typedef std::vector<T> type;
-};
-typedef std::vector<int>::size_type idArrayIdx;
-// default to standard malloc/free
-#include <cstdlib>
-#define idMalloc ::malloc
-#define idFree ::free
-// currently not aligned at all...
-#define ID_DECLARE_ALIGNED_ALLOCATOR()															 \
-	inline void* operator new(std::size_t sizeInBytes) { return idMalloc(sizeInBytes); }		   \
-	inline void operator delete(void* ptr) { idFree(ptr); }										\
-	inline void* operator new(std::size_t, void* ptr) { return ptr; }							  \
-	inline void operator delete(void*, void*) {}												   \
-	inline void* operator new[](std::size_t sizeInBytes) { return idMalloc(sizeInBytes); }		 \
-	inline void operator delete[](void* ptr) { idFree(ptr); }									  \
-	inline void* operator new[](std::size_t, void* ptr) { return ptr; }							\
-	inline void operator delete[](void*, void*) {}
-
-#include "details/IDMatVec.hpp"
-#endif
diff --git a/bullet/BulletInverseDynamics/IDConfigEigen.hpp b/bullet/BulletInverseDynamics/IDConfigEigen.hpp
deleted file mode 100644
index cbd7e8a..0000000
--- a/bullet/BulletInverseDynamics/IDConfigEigen.hpp
+++ /dev/null
@@ -1,31 +0,0 @@
-///@file Configuration for Inverse Dynamics Library with Eigen
-#ifndef INVDYNCONFIG_EIGEN_HPP_
-#define INVDYNCONFIG_EIGEN_HPP_
-#define btInverseDynamics btInverseDynamicsEigen
-#ifdef BT_USE_DOUBLE_PRECISION
-// choose double/single precision version
-typedef double idScalar;
-#else
-typedef float idScalar;
-#endif
-
-// use std::vector for arrays
-#include <vector>
-// this is to make it work with C++2003, otherwise we could do this
-// template <typename T>
-// using idArray = std::vector<T>;
-template <typename T>
-struct idArray {
-	typedef std::vector<T> type;
-};
-typedef std::vector<int>::size_type idArrayIdx;
-// default to standard malloc/free
-#include <cstdlib>
-#define ID_DECLARE_ALIGNED_ALLOCATOR() EIGEN_MAKE_ALIGNED_OPERATOR_NEW
-// Note on interfaces:
-// Eigen::Matrix has data(), to get c-array storage
-// HOWEVER: default storage is column-major!
-#define ID_LINEAR_MATH_USE_EIGEN
-#include "Eigen/Eigen"
-#include "details/IDEigenInterface.hpp"
-#endif
diff --git a/bullet/BulletInverseDynamics/details/IDEigenInterface.hpp b/bullet/BulletInverseDynamics/details/IDEigenInterface.hpp
deleted file mode 100644
index 836395c..0000000
--- a/bullet/BulletInverseDynamics/details/IDEigenInterface.hpp
+++ /dev/null
@@ -1,36 +0,0 @@
-#ifndef INVDYNEIGENINTERFACE_HPP_
-#define INVDYNEIGENINTERFACE_HPP_
-#include "../IDConfig.hpp"
-namespace btInverseDynamics {
-
-#define BT_ID_HAVE_MAT3X
-
-#ifdef BT_USE_DOUBLE_PRECISION
-typedef Eigen::Matrix<double, Eigen::Dynamic, 1, Eigen::DontAlign> vecx;
-typedef Eigen::Matrix<double, 3, 1, Eigen::DontAlign> vec3;
-typedef Eigen::Matrix<double, 3, 3, Eigen::DontAlign> mat33;
-typedef Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::DontAlign> matxx;
-typedef Eigen::Matrix<double, 3, Eigen::Dynamic, Eigen::DontAlign> mat3x;
-#else
-typedef Eigen::Matrix<float, Eigen::Dynamic, 1, Eigen::DontAlign> vecx;
-typedef Eigen::Matrix<float, 3, 1, Eigen::DontAlign> vec3;
-typedef Eigen::Matrix<float, 3, 3, Eigen::DontAlign> mat33;
-typedef Eigen::Matrix<float, Eigen::Dynamic, Eigen::Dynamic, Eigen::DontAlign> matxx;
-typedef Eigen::Matrix<float, 3, Eigen::Dynamic, Eigen::DontAlign> mat3x;
-#endif
-
-inline void resize(mat3x &m, Eigen::Index size) {
-    m.resize(3, size);
-    m.setZero();
-}
-
-inline void setMatxxElem(const idArrayIdx row, const idArrayIdx col, const idScalar val, matxx*m){
-    (*m)(row, col) = val;
-}
-
-inline void setMat3xElem(const idArrayIdx row, const idArrayIdx col, const idScalar val, mat3x*m){
-    (*m)(row, col) = val;
-}
-
-}
-#endif  // INVDYNEIGENINTERFACE_HPP_
diff --git a/bullet/BulletInverseDynamics/details/IDMatVec.hpp b/bullet/BulletInverseDynamics/details/IDMatVec.hpp
deleted file mode 100644
index 4d3f6c8..0000000
--- a/bullet/BulletInverseDynamics/details/IDMatVec.hpp
+++ /dev/null
@@ -1,415 +0,0 @@
-/// @file Built-In Matrix-Vector functions
-#ifndef IDMATVEC_HPP_
-#define IDMATVEC_HPP_
-
-#include <cstdlib>
-
-#include "../IDConfig.hpp"
-#define BT_ID_HAVE_MAT3X
-
-namespace btInverseDynamics {
-class vec3;
-class vecx;
-class mat33;
-class matxx;
-class mat3x;
-
-/// This is a very basic implementation to enable stand-alone use of the library.
-/// The implementation is not really optimized and misses many features that you would
-/// want from a "fully featured" linear math library.
-class vec3 {
-public:
-	idScalar& operator()(int i) { return m_data[i]; }
-	const idScalar& operator()(int i) const { return m_data[i]; }
-	const int size() const { return 3; }
-	const vec3& operator=(const vec3& rhs);
-	const vec3& operator+=(const vec3& b);
-	const vec3& operator-=(const vec3& b);
-	vec3 cross(const vec3& b) const;
-	idScalar dot(const vec3& b) const;
-
-	friend vec3 operator*(const mat33& a, const vec3& b);
-	friend vec3 operator*(const vec3& a, const idScalar& s);
-	friend vec3 operator*(const idScalar& s, const vec3& a);
-
-	friend vec3 operator+(const vec3& a, const vec3& b);
-	friend vec3 operator-(const vec3& a, const vec3& b);
-	friend vec3 operator/(const vec3& a, const idScalar& s);
-
-private:
-	idScalar m_data[3];
-};
-
-class mat33 {
-public:
-	idScalar& operator()(int i, int j) { return m_data[3 * i + j]; }
-	const idScalar& operator()(int i, int j) const { return m_data[3 * i + j]; }
-	const mat33& operator=(const mat33& rhs);
-	mat33 transpose() const;
-	const mat33& operator+=(const mat33& b);
-	const mat33& operator-=(const mat33& b);
-
-	friend mat33 operator*(const mat33& a, const mat33& b);
-	friend vec3 operator*(const mat33& a, const vec3& b);
-	friend mat33 operator*(const mat33& a, const idScalar& s);
-	friend mat33 operator*(const idScalar& s, const mat33& a);
-	friend mat33 operator+(const mat33& a, const mat33& b);
-	friend mat33 operator-(const mat33& a, const mat33& b);
-	friend mat33 operator/(const mat33& a, const idScalar& s);
-
-private:
-	// layout is [0,1,2;3,4,5;6,7,8]
-	idScalar m_data[9];
-};
-
-class vecx {
-public:
-	vecx(int size) : m_size(size) {
-		m_data = static_cast<idScalar*>(idMalloc(sizeof(idScalar) * size));
-	}
-	~vecx() { idFree(m_data); }
-	const vecx& operator=(const vecx& rhs);
-	idScalar& operator()(int i) { return m_data[i]; }
-	const idScalar& operator()(int i) const { return m_data[i]; }
-	const int& size() const { return m_size; }
-
-	friend vecx operator*(const vecx& a, const idScalar& s);
-	friend vecx operator*(const idScalar& s, const vecx& a);
-
-	friend vecx operator+(const vecx& a, const vecx& b);
-	friend vecx operator-(const vecx& a, const vecx& b);
-	friend vecx operator/(const vecx& a, const idScalar& s);
-
-private:
-	int m_size;
-	idScalar* m_data;
-};
-
-class matxx {
-public:
-    matxx() {
-        m_data = 0x0;
-        m_cols=0;
-        m_rows=0;
-    }
-	matxx(int rows, int cols) : m_rows(rows), m_cols(cols) {
-		m_data = static_cast<idScalar*>(idMalloc(sizeof(idScalar) * rows * cols));
-	}
-	~matxx() { idFree(m_data); }
-	idScalar& operator()(int row, int col) { return m_data[row * m_cols + col]; }
-	const idScalar& operator()(int row, int col) const { return m_data[row * m_cols + col]; }
-	const int& rows() const { return m_rows; }
-	const int& cols() const { return m_cols; }
-
-private:
-	int m_rows;
-	int m_cols;
-	idScalar* m_data;
-};
-
-class mat3x {
-public:
-    mat3x() {
-        m_data = 0x0;
-        m_cols=0;
-    }
-    mat3x(const mat3x&rhs) {
-        m_cols=rhs.m_cols;
-        allocate();
-        *this = rhs;
-    }
-    mat3x(int rows, int cols): m_cols(cols) {
-        allocate();
-    };
-    void operator=(const mat3x& rhs) {
-	if (m_cols != rhs.m_cols) {
-            error_message("size missmatch, cols= %d but rhs.cols= %d\n", cols(), rhs.cols());
-            abort();
-	}
-        for(int i=0;i<3*m_cols;i++) {
-            m_data[i] = rhs.m_data[i];
-        }
-    }
-
-    ~mat3x() {
-        free();
-    }
-    idScalar& operator()(int row, int col) { return m_data[row * m_cols + col]; }
-    const idScalar& operator()(int row, int col) const { return m_data[row * m_cols + col]; }
-    int rows() const { return m_rows; }
-    const int& cols() const { return m_cols; }
-    void resize(int rows, int cols) {
-        m_cols=cols;
-        free();
-        allocate();
-    }
-    void setZero() {
-        memset(m_data,0x0,sizeof(idScalar)*m_rows*m_cols);
-    }
-    // avoid operators that would allocate -- use functions sub/add/mul in IDMath.hpp instead
-private:
-    void allocate(){m_data = static_cast<idScalar*>(idMalloc(sizeof(idScalar) * m_rows * m_cols));}
-    void free() { idFree(m_data);}
-    enum {m_rows=3};
-    int m_cols;
-    idScalar* m_data;
-};
-
-inline void resize(mat3x &m, idArrayIdx size) {
-    m.resize(3, size);
-    m.setZero();
-}
-
-//////////////////////////////////////////////////
-// Implementations
-inline const vec3& vec3::operator=(const vec3& rhs) {
-	if (&rhs != this) {
-		memcpy(m_data, rhs.m_data, 3 * sizeof(idScalar));
-	}
-	return *this;
-}
-
-inline vec3 vec3::cross(const vec3& b) const {
-	vec3 result;
-	result.m_data[0] = m_data[1] * b.m_data[2] - m_data[2] * b.m_data[1];
-	result.m_data[1] = m_data[2] * b.m_data[0] - m_data[0] * b.m_data[2];
-	result.m_data[2] = m_data[0] * b.m_data[1] - m_data[1] * b.m_data[0];
-
-	return result;
-}
-
-inline idScalar vec3::dot(const vec3& b) const {
-	return m_data[0] * b.m_data[0] + m_data[1] * b.m_data[1] + m_data[2] * b.m_data[2];
-}
-
-inline const mat33& mat33::operator=(const mat33& rhs) {
-	if (&rhs != this) {
-		memcpy(m_data, rhs.m_data, 9 * sizeof(idScalar));
-	}
-	return *this;
-}
-inline mat33 mat33::transpose() const {
-	mat33 result;
-	result.m_data[0] = m_data[0];
-	result.m_data[1] = m_data[3];
-	result.m_data[2] = m_data[6];
-	result.m_data[3] = m_data[1];
-	result.m_data[4] = m_data[4];
-	result.m_data[5] = m_data[7];
-	result.m_data[6] = m_data[2];
-	result.m_data[7] = m_data[5];
-	result.m_data[8] = m_data[8];
-
-	return result;
-}
-
-inline mat33 operator*(const mat33& a, const mat33& b) {
-	mat33 result;
-	result.m_data[0] =
-		a.m_data[0] * b.m_data[0] + a.m_data[1] * b.m_data[3] + a.m_data[2] * b.m_data[6];
-	result.m_data[1] =
-		a.m_data[0] * b.m_data[1] + a.m_data[1] * b.m_data[4] + a.m_data[2] * b.m_data[7];
-	result.m_data[2] =
-		a.m_data[0] * b.m_data[2] + a.m_data[1] * b.m_data[5] + a.m_data[2] * b.m_data[8];
-	result.m_data[3] =
-		a.m_data[3] * b.m_data[0] + a.m_data[4] * b.m_data[3] + a.m_data[5] * b.m_data[6];
-	result.m_data[4] =
-		a.m_data[3] * b.m_data[1] + a.m_data[4] * b.m_data[4] + a.m_data[5] * b.m_data[7];
-	result.m_data[5] =
-		a.m_data[3] * b.m_data[2] + a.m_data[4] * b.m_data[5] + a.m_data[5] * b.m_data[8];
-	result.m_data[6] =
-		a.m_data[6] * b.m_data[0] + a.m_data[7] * b.m_data[3] + a.m_data[8] * b.m_data[6];
-	result.m_data[7] =
-		a.m_data[6] * b.m_data[1] + a.m_data[7] * b.m_data[4] + a.m_data[8] * b.m_data[7];
-	result.m_data[8] =
-		a.m_data[6] * b.m_data[2] + a.m_data[7] * b.m_data[5] + a.m_data[8] * b.m_data[8];
-
-	return result;
-}
-
-inline const mat33& mat33::operator+=(const mat33& b) {
-	for (int i = 0; i < 9; i++) {
-		m_data[i] += b.m_data[i];
-	}
-
-	return *this;
-}
-
-inline const mat33& mat33::operator-=(const mat33& b) {
-	for (int i = 0; i < 9; i++) {
-		m_data[i] -= b.m_data[i];
-	}
-	return *this;
-}
-
-inline vec3 operator*(const mat33& a, const vec3& b) {
-	vec3 result;
-
-	result.m_data[0] =
-		a.m_data[0] * b.m_data[0] + a.m_data[1] * b.m_data[1] + a.m_data[2] * b.m_data[2];
-	result.m_data[1] =
-		a.m_data[3] * b.m_data[0] + a.m_data[4] * b.m_data[1] + a.m_data[5] * b.m_data[2];
-	result.m_data[2] =
-		a.m_data[6] * b.m_data[0] + a.m_data[7] * b.m_data[1] + a.m_data[8] * b.m_data[2];
-
-	return result;
-}
-
-inline const vec3& vec3::operator+=(const vec3& b) {
-	for (int i = 0; i < 3; i++) {
-		m_data[i] += b.m_data[i];
-	}
-	return *this;
-}
-
-inline const vec3& vec3::operator-=(const vec3& b) {
-	for (int i = 0; i < 3; i++) {
-		m_data[i] -= b.m_data[i];
-	}
-	return *this;
-}
-
-inline mat33 operator*(const mat33& a, const idScalar& s) {
-	mat33 result;
-	for (int i = 0; i < 9; i++) {
-		result.m_data[i] = a.m_data[i] * s;
-	}
-	return result;
-}
-
-inline mat33 operator*(const idScalar& s, const mat33& a) { return a * s; }
-
-inline vec3 operator*(const vec3& a, const idScalar& s) {
-	vec3 result;
-	for (int i = 0; i < 3; i++) {
-		result.m_data[i] = a.m_data[i] * s;
-	}
-	return result;
-}
-inline vec3 operator*(const idScalar& s, const vec3& a) { return a * s; }
-
-inline mat33 operator+(const mat33& a, const mat33& b) {
-	mat33 result;
-	for (int i = 0; i < 9; i++) {
-		result.m_data[i] = a.m_data[i] + b.m_data[i];
-	}
-	return result;
-}
-inline vec3 operator+(const vec3& a, const vec3& b) {
-	vec3 result;
-	for (int i = 0; i < 3; i++) {
-		result.m_data[i] = a.m_data[i] + b.m_data[i];
-	}
-	return result;
-}
-
-inline mat33 operator-(const mat33& a, const mat33& b) {
-	mat33 result;
-	for (int i = 0; i < 9; i++) {
-		result.m_data[i] = a.m_data[i] - b.m_data[i];
-	}
-	return result;
-}
-inline vec3 operator-(const vec3& a, const vec3& b) {
-	vec3 result;
-	for (int i = 0; i < 3; i++) {
-		result.m_data[i] = a.m_data[i] - b.m_data[i];
-	}
-	return result;
-}
-
-inline mat33 operator/(const mat33& a, const idScalar& s) {
-	mat33 result;
-	for (int i = 0; i < 9; i++) {
-		result.m_data[i] = a.m_data[i] / s;
-	}
-	return result;
-}
-
-inline vec3 operator/(const vec3& a, const idScalar& s) {
-	vec3 result;
-	for (int i = 0; i < 3; i++) {
-		result.m_data[i] = a.m_data[i] / s;
-	}
-	return result;
-}
-
-inline const vecx& vecx::operator=(const vecx& rhs) {
-	if (size() != rhs.size()) {
-		error_message("size missmatch, size()= %d but rhs.size()= %d\n", size(), rhs.size());
-		abort();
-	}
-	if (&rhs != this) {
-		memcpy(m_data, rhs.m_data, rhs.size() * sizeof(idScalar));
-	}
-	return *this;
-}
-inline vecx operator*(const vecx& a, const idScalar& s) {
-	vecx result(a.size());
-	for (int i = 0; i < result.size(); i++) {
-		result.m_data[i] = a.m_data[i] * s;
-	}
-	return result;
-}
-inline vecx operator*(const idScalar& s, const vecx& a) { return a * s; }
-inline vecx operator+(const vecx& a, const vecx& b) {
-	vecx result(a.size());
-	// TODO: error handling for a.size() != b.size()??
-	if (a.size() != b.size()) {
-		error_message("size missmatch. a.size()= %d, b.size()= %d\n", a.size(), b.size());
-		abort();
-	}
-	for (int i = 0; i < a.size(); i++) {
-		result.m_data[i] = a.m_data[i] + b.m_data[i];
-	}
-
-	return result;
-}
-inline vecx operator-(const vecx& a, const vecx& b) {
-	vecx result(a.size());
-	// TODO: error handling for a.size() != b.size()??
-	if (a.size() != b.size()) {
-		error_message("size missmatch. a.size()= %d, b.size()= %d\n", a.size(), b.size());
-		abort();
-	}
-	for (int i = 0; i < a.size(); i++) {
-		result.m_data[i] = a.m_data[i] - b.m_data[i];
-	}
-	return result;
-}
-inline vecx operator/(const vecx& a, const idScalar& s) {
-	vecx result(a.size());
-	for (int i = 0; i < result.size(); i++) {
-		result.m_data[i] = a.m_data[i] / s;
-	}
-
-	return result;
-}
-
-inline vec3 operator*(const mat3x& a, const vecx& b) {
-    vec3 result;
-    if (a.cols() != b.size()) {
-        error_message("size missmatch. a.cols()= %d, b.size()= %d\n", a.cols(), b.size());
-        abort();
-    }
-    result(0)=0.0;
-    result(1)=0.0;
-    result(2)=0.0;
-    for(int i=0;i<b.size();i++) {
-        for(int k=0;k<3;k++) {
-            result(k)+=a(k,i)*b(i);
-        }
-    }
-    return result;
-}
-
-inline void setMatxxElem(const idArrayIdx row, const idArrayIdx col, const idScalar val, matxx*m){
-    (*m)(row, col) = val;
-}
-
-inline void setMat3xElem(const idArrayIdx row, const idArrayIdx col, const idScalar val, mat3x*m){
-    (*m)(row, col) = val;
-}
-
-} // namespace btInverseDynamcis
-#endif
diff --git a/bullet/BulletSoftBody/btSoftBody.h b/bullet/BulletSoftBody/btSoftBody.h
index 11ef57b..ada0dfd 100644
--- a/bullet/BulletSoftBody/btSoftBody.h
+++ b/bullet/BulletSoftBody/btSoftBody.h
@@ -617,7 +617,7 @@ public:
 		RayFromToCaster(const btVector3& rayFrom,const btVector3& rayTo,btScalar mxt);
 		void					Process(const btDbvtNode* leaf);
 
-		static inline btScalar	rayFromToTriangle(const btVector3& rayFrom,
+		static /*inline*/ btScalar	rayFromToTriangle(const btVector3& rayFrom,
 			const btVector3& rayTo,
 			const btVector3& rayNormalizedDirection,
 			const btVector3& a,
diff --git a/bullet/BulletSoftBody/btSoftMultiBodyDynamicsWorld.h b/bullet/BulletSoftBody/btSoftMultiBodyDynamicsWorld.h
index 7e3ab32..6d46a21 100644
--- a/bullet/BulletSoftBody/btSoftMultiBodyDynamicsWorld.h
+++ b/bullet/BulletSoftBody/btSoftMultiBodyDynamicsWorld.h
@@ -20,7 +20,9 @@ subject to the following restrictions:
 #include "BulletDynamics/Featherstone/btMultiBodyDynamicsWorld.h"
 #include "BulletSoftBody/btSoftBody.h"
 
+#ifndef BT_SOFT_RIGID_DYNAMICS_WORLD_H
 typedef	btAlignedObjectArray<btSoftBody*> btSoftBodyArray;
+#endif
 
 class btSoftBodySolver;
 
diff --git a/bullet/LinearMath/btQuickprof.h b/bullet/LinearMath/btQuickprof.h
index fd00307..7b38d71 100644
--- a/bullet/LinearMath/btQuickprof.h
+++ b/bullet/LinearMath/btQuickprof.h
@@ -65,9 +65,11 @@ btLeaveProfileZoneFunc* btGetCurrentLeaveProfileZoneFunc();
 void btSetCustomEnterProfileZoneFunc(btEnterProfileZoneFunc* enterFunc);
 void btSetCustomLeaveProfileZoneFunc(btLeaveProfileZoneFunc* leaveFunc);
 
-
+#ifndef BT_NO_PROFILE // FIX redefinition
 //To disable built-in profiling, please comment out next line
 //#define BT_NO_PROFILE 1
+#endif //BT_NO_PROFILE
+
 #ifndef BT_NO_PROFILE
 //btQuickprofGetCurrentThreadIndex will return -1 if thread index cannot be determined, 
 //otherwise returns thread index in range [0..maxThreads]
diff --git a/bullet/LinearMath/btScalar.h b/bullet/LinearMath/btScalar.h
index 0075456..5a5b66c 100644
--- a/bullet/LinearMath/btScalar.h
+++ b/bullet/LinearMath/btScalar.h
@@ -175,12 +175,13 @@ inline int	btGetVersion()
 	//non-windows systems
 
 #if (defined (__APPLE__) && (!defined (BT_USE_DOUBLE_PRECISION)))
-    #if defined (__i386__) || defined (__x86_64__)
-		#define BT_USE_SIMD_VECTOR3
-		#define BT_USE_SSE
+	#include <TargetConditionals.h>
+	#if (defined (__i386__) || defined (__x86_64__)) && (!(TARGET_IPHONE_SIMULATOR))
+		//#define BT_USE_SIMD_VECTOR3
+		//#define BT_USE_SSE
 		//BT_USE_SSE_IN_API is enabled on Mac OSX by default, because memory is automatically aligned on 16-byte boundaries
 		//if apps run into issues, we will disable the next line
-		#define BT_USE_SSE_IN_API
+		//#define BT_USE_SSE_IN_API
         #ifdef BT_USE_SSE
             // include appropriate SSE level
             #if defined (__SSE4_1__)
diff --git a/extras/InverseDynamics/BulletInverseDynamicsUtilsCommon.h b/extras/InverseDynamics/BulletInverseDynamicsUtilsCommon.h
index 25e77cd..ac14e87 100644
--- a/extras/InverseDynamics/BulletInverseDynamicsUtilsCommon.h
+++ b/extras/InverseDynamics/BulletInverseDynamicsUtilsCommon.h
@@ -2,7 +2,7 @@
 #define BULLET_INVERSE_DYNAMICS_UTILS_COMMON_H
 #include "CoilCreator.hpp"
 #include "MultiBodyTreeCreator.hpp"
-#include "btMultiBodyFromURDF.hpp"
+//#include "btMultiBodyFromURDF.hpp"
 #include "DillCreator.hpp"
 #include "MultiBodyTreeDebugGraph.hpp"
 #include "btMultiBodyTreeCreator.hpp"
diff --git a/extras/InverseDynamics/btMultiBodyFromURDF.hpp b/extras/InverseDynamics/btMultiBodyFromURDF.hpp
deleted file mode 100644
index d627ea9..0000000
--- a/extras/InverseDynamics/btMultiBodyFromURDF.hpp
+++ /dev/null
@@ -1,91 +0,0 @@
-#ifndef BTMULTIBODYFROMURDF_HPP
-#define BTMULTIBODYFROMURDF_HPP
-
-#include "btBulletDynamicsCommon.h"
-#include "BulletDynamics/Featherstone/btMultiBodyConstraintSolver.h"
-#include "BulletDynamics/Featherstone/btMultiBodyDynamicsWorld.h"
-#include "BulletDynamics/Featherstone/btMultiBodyLinkCollider.h"
-#include "BulletDynamics/Featherstone/btMultiBodyPoint2Point.h"
-#include "../../examples/CommonInterfaces/CommonGUIHelperInterface.h"
-#include "../../examples/Importers/ImportURDFDemo/BulletUrdfImporter.h"
-#include "../../examples/Importers/ImportURDFDemo/URDF2Bullet.h"
-#include "../../examples/Importers/ImportURDFDemo/MyMultiBodyCreator.h"
-#include "../../examples/Importers/ImportURDFDemo/URDF2Bullet.h"
-
-/// Create a btMultiBody model from URDF.
-/// This is adapted from Bullet URDF loader example
-class MyBtMultiBodyFromURDF {
-public:
-    /// ctor
-    /// @param gravity gravitational acceleration (in world frame)
-    /// @param base_fixed if true, the root body is treated as fixed,
-    ///        if false, it is treated as floating
-    MyBtMultiBodyFromURDF(const btVector3 &gravity, const bool base_fixed)
-        : m_gravity(gravity), m_base_fixed(base_fixed) {
-        m_broadphase = 0x0;
-        m_dispatcher = 0x0;
-        m_solver = 0x0;
-        m_collisionConfiguration = 0x0;
-        m_dynamicsWorld = 0x0;
-        m_multibody = 0x0;
-    }
-    /// dtor
-    ~MyBtMultiBodyFromURDF() {
-        delete m_dynamicsWorld;
-        delete m_solver;
-        delete m_broadphase;
-        delete m_dispatcher;
-        delete m_collisionConfiguration;
-        delete m_multibody;
-    }
-    /// @param name path to urdf file
-    void setFileName(const std::string name) { m_filename = name; }
-    /// load urdf file and build btMultiBody model
-    void init() {
-        this->createEmptyDynamicsWorld();
-        m_dynamicsWorld->setGravity(m_gravity);
-        BulletURDFImporter urdf_importer(&m_nogfx,0);
-        URDFImporterInterface &u2b(urdf_importer);
-        bool loadOk = u2b.loadURDF(m_filename.c_str(), m_base_fixed);
-
-        if (loadOk) {
-            btTransform identityTrans;
-            identityTrans.setIdentity();
-            MyMultiBodyCreator creation(&m_nogfx);
-            const bool use_multibody = true;
-            ConvertURDF2Bullet(u2b, creation, identityTrans, m_dynamicsWorld, use_multibody,
-                               u2b.getPathPrefix());
-            m_multibody = creation.getBulletMultiBody();
-            m_dynamicsWorld->stepSimulation(1. / 240., 0);
-        }
-    }
-    /// @return pointer to the btMultiBody model
-    btMultiBody *getBtMultiBody() { return m_multibody; }
-
-private:
-    // internal utility function
-    void createEmptyDynamicsWorld() {
-        m_collisionConfiguration = new btDefaultCollisionConfiguration();
-
-        /// use the default collision dispatcher. For parallel processing you can use a diffent
-        /// dispatcher (see Extras/BulletMultiThreaded)
-        m_dispatcher = new btCollisionDispatcher(m_collisionConfiguration);
-        m_broadphase = new btDbvtBroadphase();
-        m_solver = new btMultiBodyConstraintSolver;
-        m_dynamicsWorld = new btMultiBodyDynamicsWorld(m_dispatcher, m_broadphase, m_solver,
-                                                       m_collisionConfiguration);
-        m_dynamicsWorld->setGravity(m_gravity);
-    }
-
-    btBroadphaseInterface *m_broadphase;
-    btCollisionDispatcher *m_dispatcher;
-    btMultiBodyConstraintSolver *m_solver;
-    btDefaultCollisionConfiguration *m_collisionConfiguration;
-    btMultiBodyDynamicsWorld *m_dynamicsWorld;
-    std::string m_filename;
-    DummyGUIHelper m_nogfx;
-    btMultiBody *m_multibody;
-    const btVector3 m_gravity;
-    const bool m_base_fixed;
-};
-#endif  // BTMULTIBODYFROMURDF_HPP
-- 

diff --git a/bullet/BulletCollision/BroadphaseCollision/btAxisSweep3Internal.h b/bullet/BulletCollision/BroadphaseCollision/btAxisSweep3Internal.h
new file mode 100644
index 0000000..2c4d41b
--- /dev/null
+++ b/bullet/BulletCollision/BroadphaseCollision/btAxisSweep3Internal.h
@@ -0,0 +1,1022 @@
+//Bullet Continuous Collision Detection and Physics Library
+//Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/
+
+//
+// btAxisSweep3.h
+//
+// Copyright (c) 2006 Simon Hobbs
+//
+// This software is provided 'as-is', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software.
+//
+// Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions:
+//
+// 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
+//
+// 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
+//
+// 3. This notice may not be removed or altered from any source distribution.
+
+#ifndef BT_AXIS_SWEEP_3_INTERNAL_H
+#define BT_AXIS_SWEEP_3_INTERNAL_H
+
+#include "LinearMath/btVector3.h"
+#include "btOverlappingPairCache.h"
+#include "btBroadphaseInterface.h"
+#include "btBroadphaseProxy.h"
+#include "btOverlappingPairCallback.h"
+#include "btDbvtBroadphase.h"
+
+//#define DEBUG_BROADPHASE 1
+#define USE_OVERLAP_TEST_ON_REMOVES 1
+
+/// The internal templace class btAxisSweep3Internal implements the sweep and prune broadphase.
+/// It uses quantized integers to represent the begin and end points for each of the 3 axis.
+/// Dont use this class directly, use btAxisSweep3 or bt32BitAxisSweep3 instead.
+template <typename BP_FP_INT_TYPE>
+class btAxisSweep3Internal : public btBroadphaseInterface
+{
+protected:
+
+	BP_FP_INT_TYPE	m_bpHandleMask;
+	BP_FP_INT_TYPE	m_handleSentinel;
+
+public:
+	
+ BT_DECLARE_ALIGNED_ALLOCATOR();
+
+	class Edge
+	{
+	public:
+		BP_FP_INT_TYPE m_pos;			// low bit is min/max
+		BP_FP_INT_TYPE m_handle;
+
+		BP_FP_INT_TYPE IsMax() const {return static_cast<BP_FP_INT_TYPE>(m_pos & 1);}
+	};
+
+public:
+	class	Handle : public btBroadphaseProxy
+	{
+	public:
+	BT_DECLARE_ALIGNED_ALLOCATOR();
+	
+		// indexes into the edge arrays
+		BP_FP_INT_TYPE m_minEdges[3], m_maxEdges[3];		// 6 * 2 = 12
+//		BP_FP_INT_TYPE m_uniqueId;
+		btBroadphaseProxy*	m_dbvtProxy;//for faster raycast
+		//void* m_pOwner; this is now in btBroadphaseProxy.m_clientObject
+	
+		SIMD_FORCE_INLINE void SetNextFree(BP_FP_INT_TYPE next) {m_minEdges[0] = next;}
+		SIMD_FORCE_INLINE BP_FP_INT_TYPE GetNextFree() const {return m_minEdges[0];}
+	};		// 24 bytes + 24 for Edge structures = 44 bytes total per entry
+
+	
+protected:
+	btVector3 m_worldAabbMin;						// overall system bounds
+	btVector3 m_worldAabbMax;						// overall system bounds
+
+	btVector3 m_quantize;						// scaling factor for quantization
+
+	BP_FP_INT_TYPE m_numHandles;						// number of active handles
+	BP_FP_INT_TYPE m_maxHandles;						// max number of handles
+	Handle* m_pHandles;						// handles pool
+	
+	BP_FP_INT_TYPE m_firstFreeHandle;		// free handles list
+
+	Edge* m_pEdges[3];						// edge arrays for the 3 axes (each array has m_maxHandles * 2 + 2 sentinel entries)
+	void* m_pEdgesRawPtr[3];
+
+	btOverlappingPairCache* m_pairCache;
+
+	///btOverlappingPairCallback is an additional optional user callback for adding/removing overlapping pairs, similar interface to btOverlappingPairCache.
+	btOverlappingPairCallback* m_userPairCallback;
+	
+	bool	m_ownsPairCache;
+
+	int	m_invalidPair;
+
+	///additional dynamic aabb structure, used to accelerate ray cast queries.
+	///can be disabled using a optional argument in the constructor
+	btDbvtBroadphase*	m_raycastAccelerator;
+	btOverlappingPairCache*	m_nullPairCache;
+
+
+	// allocation/deallocation
+	BP_FP_INT_TYPE allocHandle();
+	void freeHandle(BP_FP_INT_TYPE handle);
+	
+
+	bool testOverlap2D(const Handle* pHandleA, const Handle* pHandleB,int axis0,int axis1);
+
+#ifdef DEBUG_BROADPHASE
+	void debugPrintAxis(int axis,bool checkCardinality=true);
+#endif //DEBUG_BROADPHASE
+
+	//Overlap* AddOverlap(BP_FP_INT_TYPE handleA, BP_FP_INT_TYPE handleB);
+	//void RemoveOverlap(BP_FP_INT_TYPE handleA, BP_FP_INT_TYPE handleB);
+
+	
+
+	void sortMinDown(int axis, BP_FP_INT_TYPE edge, btDispatcher* dispatcher, bool updateOverlaps );
+	void sortMinUp(int axis, BP_FP_INT_TYPE edge, btDispatcher* dispatcher, bool updateOverlaps );
+	void sortMaxDown(int axis, BP_FP_INT_TYPE edge, btDispatcher* dispatcher, bool updateOverlaps );
+	void sortMaxUp(int axis, BP_FP_INT_TYPE edge, btDispatcher* dispatcher, bool updateOverlaps );
+
+public:
+
+	btAxisSweep3Internal(const btVector3& worldAabbMin,const btVector3& worldAabbMax, BP_FP_INT_TYPE handleMask, BP_FP_INT_TYPE handleSentinel, BP_FP_INT_TYPE maxHandles = 16384, btOverlappingPairCache* pairCache=0,bool disableRaycastAccelerator = false);
+
+	virtual	~btAxisSweep3Internal();
+
+	BP_FP_INT_TYPE getNumHandles() const
+	{
+		return m_numHandles;
+	}
+
+	virtual void	calculateOverlappingPairs(btDispatcher* dispatcher);
+	
+	BP_FP_INT_TYPE addHandle(const btVector3& aabbMin,const btVector3& aabbMax, void* pOwner, int collisionFilterGroup, int collisionFilterMask,btDispatcher* dispatcher);
+	void removeHandle(BP_FP_INT_TYPE handle,btDispatcher* dispatcher);
+	void updateHandle(BP_FP_INT_TYPE handle, const btVector3& aabbMin,const btVector3& aabbMax,btDispatcher* dispatcher);
+	SIMD_FORCE_INLINE Handle* getHandle(BP_FP_INT_TYPE index) const {return m_pHandles + index;}
+
+	virtual void resetPool(btDispatcher* dispatcher);
+
+	void	processAllOverlappingPairs(btOverlapCallback* callback);
+
+	//Broadphase Interface
+	virtual btBroadphaseProxy*	createProxy(  const btVector3& aabbMin,  const btVector3& aabbMax,int shapeType,void* userPtr , int collisionFilterGroup, int collisionFilterMask,btDispatcher* dispatcher);
+	virtual void	destroyProxy(btBroadphaseProxy* proxy,btDispatcher* dispatcher);
+	virtual void	setAabb(btBroadphaseProxy* proxy,const btVector3& aabbMin,const btVector3& aabbMax,btDispatcher* dispatcher);
+	virtual void  getAabb(btBroadphaseProxy* proxy,btVector3& aabbMin, btVector3& aabbMax ) const;
+	
+	virtual void	rayTest(const btVector3& rayFrom,const btVector3& rayTo, btBroadphaseRayCallback& rayCallback, const btVector3& aabbMin=btVector3(0,0,0), const btVector3& aabbMax = btVector3(0,0,0));
+	virtual void	aabbTest(const btVector3& aabbMin, const btVector3& aabbMax, btBroadphaseAabbCallback& callback);
+
+	
+	void quantize(BP_FP_INT_TYPE* out, const btVector3& point, int isMax) const;
+	///unQuantize should be conservative: aabbMin/aabbMax should be larger then 'getAabb' result
+	void unQuantize(btBroadphaseProxy* proxy,btVector3& aabbMin, btVector3& aabbMax ) const;
+	
+	bool	testAabbOverlap(btBroadphaseProxy* proxy0,btBroadphaseProxy* proxy1);
+
+	btOverlappingPairCache*	getOverlappingPairCache()
+	{
+		return m_pairCache;
+	}
+	const btOverlappingPairCache*	getOverlappingPairCache() const
+	{
+		return m_pairCache;
+	}
+
+	void	setOverlappingPairUserCallback(btOverlappingPairCallback* pairCallback)
+	{
+		m_userPairCallback = pairCallback;
+	}
+	const btOverlappingPairCallback*	getOverlappingPairUserCallback() const
+	{
+		return m_userPairCallback;
+	}
+
+	///getAabb returns the axis aligned bounding box in the 'global' coordinate frame
+	///will add some transform later
+	virtual void getBroadphaseAabb(btVector3& aabbMin,btVector3& aabbMax) const
+	{
+		aabbMin = m_worldAabbMin;
+		aabbMax = m_worldAabbMax;
+	}
+
+	virtual void	printStats()
+	{
+/*		printf("btAxisSweep3.h\n");
+		printf("numHandles = %d, maxHandles = %d\n",m_numHandles,m_maxHandles);
+		printf("aabbMin=%f,%f,%f,aabbMax=%f,%f,%f\n",m_worldAabbMin.getX(),m_worldAabbMin.getY(),m_worldAabbMin.getZ(),
+			m_worldAabbMax.getX(),m_worldAabbMax.getY(),m_worldAabbMax.getZ());
+			*/
+
+	}
+
+};
+
+////////////////////////////////////////////////////////////////////
+
+
+
+
+#ifdef DEBUG_BROADPHASE
+#include <stdio.h>
+
+template <typename BP_FP_INT_TYPE>
+void btAxisSweep3<BP_FP_INT_TYPE>::debugPrintAxis(int axis, bool checkCardinality)
+{
+	int numEdges = m_pHandles[0].m_maxEdges[axis];
+	printf("SAP Axis %d, numEdges=%d\n",axis,numEdges);
+
+	int i;
+	for (i=0;i<numEdges+1;i++)
+	{
+		Edge* pEdge = m_pEdges[axis] + i;
+		Handle* pHandlePrev = getHandle(pEdge->m_handle);
+		int handleIndex = pEdge->IsMax()? pHandlePrev->m_maxEdges[axis] : pHandlePrev->m_minEdges[axis];
+		char beginOrEnd;
+		beginOrEnd=pEdge->IsMax()?'E':'B';
+		printf("	[%c,h=%d,p=%x,i=%d]\n",beginOrEnd,pEdge->m_handle,pEdge->m_pos,handleIndex);
+	}
+
+	if (checkCardinality)
+		btAssert(numEdges == m_numHandles*2+1);
+}
+#endif //DEBUG_BROADPHASE
+
+template <typename BP_FP_INT_TYPE>
+btBroadphaseProxy*	btAxisSweep3Internal<BP_FP_INT_TYPE>::createProxy(  const btVector3& aabbMin,  const btVector3& aabbMax,int shapeType,void* userPtr, int collisionFilterGroup, int collisionFilterMask,btDispatcher* dispatcher)
+{
+		(void)shapeType;
+		BP_FP_INT_TYPE handleId = addHandle(aabbMin,aabbMax, userPtr,collisionFilterGroup,collisionFilterMask,dispatcher);
+		
+		Handle* handle = getHandle(handleId);
+		
+		if (m_raycastAccelerator)
+		{
+			btBroadphaseProxy* rayProxy = m_raycastAccelerator->createProxy(aabbMin,aabbMax,shapeType,userPtr,collisionFilterGroup,collisionFilterMask,dispatcher);
+			handle->m_dbvtProxy = rayProxy;
+		}
+		return handle;
+}
+
+
+
+template <typename BP_FP_INT_TYPE>
+void	btAxisSweep3Internal<BP_FP_INT_TYPE>::destroyProxy(btBroadphaseProxy* proxy,btDispatcher* dispatcher)
+{
+	Handle* handle = static_cast<Handle*>(proxy);
+	if (m_raycastAccelerator)
+		m_raycastAccelerator->destroyProxy(handle->m_dbvtProxy,dispatcher);
+	removeHandle(static_cast<BP_FP_INT_TYPE>(handle->m_uniqueId), dispatcher);
+}
+
+template <typename BP_FP_INT_TYPE>
+void	btAxisSweep3Internal<BP_FP_INT_TYPE>::setAabb(btBroadphaseProxy* proxy,const btVector3& aabbMin,const btVector3& aabbMax,btDispatcher* dispatcher)
+{
+	Handle* handle = static_cast<Handle*>(proxy);
+	handle->m_aabbMin = aabbMin;
+	handle->m_aabbMax = aabbMax;
+	updateHandle(static_cast<BP_FP_INT_TYPE>(handle->m_uniqueId), aabbMin, aabbMax,dispatcher);
+	if (m_raycastAccelerator)
+		m_raycastAccelerator->setAabb(handle->m_dbvtProxy,aabbMin,aabbMax,dispatcher);
+
+}
+
+template <typename BP_FP_INT_TYPE>
+void	btAxisSweep3Internal<BP_FP_INT_TYPE>::rayTest(const btVector3& rayFrom,const btVector3& rayTo, btBroadphaseRayCallback& rayCallback,const btVector3& aabbMin,const btVector3& aabbMax)
+{
+	if (m_raycastAccelerator)
+	{
+		m_raycastAccelerator->rayTest(rayFrom,rayTo,rayCallback,aabbMin,aabbMax);
+	} else
+	{
+		//choose axis?
+		BP_FP_INT_TYPE axis = 0;
+		//for each proxy
+		for (BP_FP_INT_TYPE i=1;i<m_numHandles*2+1;i++)
+		{
+			if (m_pEdges[axis][i].IsMax())
+			{
+				rayCallback.process(getHandle(m_pEdges[axis][i].m_handle));
+			}
+		}
+	}
+}
+
+template <typename BP_FP_INT_TYPE>
+void	btAxisSweep3Internal<BP_FP_INT_TYPE>::aabbTest(const btVector3& aabbMin, const btVector3& aabbMax, btBroadphaseAabbCallback& callback)
+{
+	if (m_raycastAccelerator)
+	{
+		m_raycastAccelerator->aabbTest(aabbMin,aabbMax,callback);
+	} else
+	{
+		//choose axis?
+		BP_FP_INT_TYPE axis = 0;
+		//for each proxy
+		for (BP_FP_INT_TYPE i=1;i<m_numHandles*2+1;i++)
+		{
+			if (m_pEdges[axis][i].IsMax())
+			{
+				Handle* handle = getHandle(m_pEdges[axis][i].m_handle);
+				if (TestAabbAgainstAabb2(aabbMin,aabbMax,handle->m_aabbMin,handle->m_aabbMax))
+				{
+					callback.process(handle);
+				}
+			}
+		}
+	}
+}
+
+
+
+template <typename BP_FP_INT_TYPE>
+void btAxisSweep3Internal<BP_FP_INT_TYPE>::getAabb(btBroadphaseProxy* proxy,btVector3& aabbMin, btVector3& aabbMax ) const
+{
+	Handle* pHandle = static_cast<Handle*>(proxy);
+	aabbMin = pHandle->m_aabbMin;
+	aabbMax = pHandle->m_aabbMax;
+}
+
+
+template <typename BP_FP_INT_TYPE>
+void btAxisSweep3Internal<BP_FP_INT_TYPE>::unQuantize(btBroadphaseProxy* proxy,btVector3& aabbMin, btVector3& aabbMax ) const
+{
+	Handle* pHandle = static_cast<Handle*>(proxy);
+
+	unsigned short vecInMin[3];
+	unsigned short vecInMax[3];
+
+	vecInMin[0] = m_pEdges[0][pHandle->m_minEdges[0]].m_pos ;
+	vecInMax[0] = m_pEdges[0][pHandle->m_maxEdges[0]].m_pos +1 ;
+	vecInMin[1] = m_pEdges[1][pHandle->m_minEdges[1]].m_pos ;
+	vecInMax[1] = m_pEdges[1][pHandle->m_maxEdges[1]].m_pos +1 ;
+	vecInMin[2] = m_pEdges[2][pHandle->m_minEdges[2]].m_pos ;
+	vecInMax[2] = m_pEdges[2][pHandle->m_maxEdges[2]].m_pos +1 ;
+	
+	aabbMin.setValue((btScalar)(vecInMin[0]) / (m_quantize.getX()),(btScalar)(vecInMin[1]) / (m_quantize.getY()),(btScalar)(vecInMin[2]) / (m_quantize.getZ()));
+	aabbMin += m_worldAabbMin;
+	
+	aabbMax.setValue((btScalar)(vecInMax[0]) / (m_quantize.getX()),(btScalar)(vecInMax[1]) / (m_quantize.getY()),(btScalar)(vecInMax[2]) / (m_quantize.getZ()));
+	aabbMax += m_worldAabbMin;
+}
+
+
+
+
+template <typename BP_FP_INT_TYPE>
+btAxisSweep3Internal<BP_FP_INT_TYPE>::btAxisSweep3Internal(const btVector3& worldAabbMin,const btVector3& worldAabbMax, BP_FP_INT_TYPE handleMask, BP_FP_INT_TYPE handleSentinel,BP_FP_INT_TYPE userMaxHandles, btOverlappingPairCache* pairCache , bool disableRaycastAccelerator)
+:m_bpHandleMask(handleMask),
+m_handleSentinel(handleSentinel),
+m_pairCache(pairCache),
+m_userPairCallback(0),
+m_ownsPairCache(false),
+m_invalidPair(0),
+m_raycastAccelerator(0)
+{
+	BP_FP_INT_TYPE maxHandles = static_cast<BP_FP_INT_TYPE>(userMaxHandles+1);//need to add one sentinel handle
+
+	if (!m_pairCache)
+	{
+		void* ptr = btAlignedAlloc(sizeof(btHashedOverlappingPairCache),16);
+		m_pairCache = new(ptr) btHashedOverlappingPairCache();
+		m_ownsPairCache = true;
+	}
+
+	if (!disableRaycastAccelerator)
+	{
+		m_nullPairCache = new (btAlignedAlloc(sizeof(btNullPairCache),16)) btNullPairCache();
+		m_raycastAccelerator = new (btAlignedAlloc(sizeof(btDbvtBroadphase),16)) btDbvtBroadphase(m_nullPairCache);//m_pairCache);
+		m_raycastAccelerator->m_deferedcollide = true;//don't add/remove pairs
+	}
+
+	//btAssert(bounds.HasVolume());
+
+	// init bounds
+	m_worldAabbMin = worldAabbMin;
+	m_worldAabbMax = worldAabbMax;
+
+	btVector3 aabbSize = m_worldAabbMax - m_worldAabbMin;
+
+	BP_FP_INT_TYPE	maxInt = m_handleSentinel;
+
+	m_quantize = btVector3(btScalar(maxInt),btScalar(maxInt),btScalar(maxInt)) / aabbSize;
+
+	// allocate handles buffer, using btAlignedAlloc, and put all handles on free list
+	m_pHandles = new Handle[maxHandles];
+	
+	m_maxHandles = maxHandles;
+	m_numHandles = 0;
+
+	// handle 0 is reserved as the null index, and is also used as the sentinel
+	m_firstFreeHandle = 1;
+	{
+		for (BP_FP_INT_TYPE i = m_firstFreeHandle; i < maxHandles; i++)
+			m_pHandles[i].SetNextFree(static_cast<BP_FP_INT_TYPE>(i + 1));
+		m_pHandles[maxHandles - 1].SetNextFree(0);
+	}
+
+	{
+		// allocate edge buffers
+		for (int i = 0; i < 3; i++)
+		{
+			m_pEdgesRawPtr[i] = btAlignedAlloc(sizeof(Edge)*maxHandles*2,16);
+			m_pEdges[i] = new(m_pEdgesRawPtr[i]) Edge[maxHandles * 2];
+		}
+	}
+	//removed overlap management
+
+	// make boundary sentinels
+	
+	m_pHandles[0].m_clientObject = 0;
+
+	for (int axis = 0; axis < 3; axis++)
+	{
+		m_pHandles[0].m_minEdges[axis] = 0;
+		m_pHandles[0].m_maxEdges[axis] = 1;
+
+		m_pEdges[axis][0].m_pos = 0;
+		m_pEdges[axis][0].m_handle = 0;
+		m_pEdges[axis][1].m_pos = m_handleSentinel;
+		m_pEdges[axis][1].m_handle = 0;
+#ifdef DEBUG_BROADPHASE
+		debugPrintAxis(axis);
+#endif //DEBUG_BROADPHASE
+
+	}
+
+}
+
+template <typename BP_FP_INT_TYPE>
+btAxisSweep3Internal<BP_FP_INT_TYPE>::~btAxisSweep3Internal()
+{
+	if (m_raycastAccelerator)
+	{
+		m_nullPairCache->~btOverlappingPairCache();
+		btAlignedFree(m_nullPairCache);
+		m_raycastAccelerator->~btDbvtBroadphase();
+		btAlignedFree (m_raycastAccelerator);
+	}
+
+	for (int i = 2; i >= 0; i--)
+	{
+		btAlignedFree(m_pEdgesRawPtr[i]);
+	}
+	delete [] m_pHandles;
+
+	if (m_ownsPairCache)
+	{
+		m_pairCache->~btOverlappingPairCache();
+		btAlignedFree(m_pairCache);
+	}
+}
+
+template <typename BP_FP_INT_TYPE>
+void btAxisSweep3Internal<BP_FP_INT_TYPE>::quantize(BP_FP_INT_TYPE* out, const btVector3& point, int isMax) const
+{
+#ifdef OLD_CLAMPING_METHOD
+	///problem with this clamping method is that the floating point during quantization might still go outside the range [(0|isMax) .. (m_handleSentinel&m_bpHandleMask]|isMax]
+	///see http://code.google.com/p/bullet/issues/detail?id=87
+	btVector3 clampedPoint(point);
+	clampedPoint.setMax(m_worldAabbMin);
+	clampedPoint.setMin(m_worldAabbMax);
+	btVector3 v = (clampedPoint - m_worldAabbMin) * m_quantize;
+	out[0] = (BP_FP_INT_TYPE)(((BP_FP_INT_TYPE)v.getX() & m_bpHandleMask) | isMax);
+	out[1] = (BP_FP_INT_TYPE)(((BP_FP_INT_TYPE)v.getY() & m_bpHandleMask) | isMax);
+	out[2] = (BP_FP_INT_TYPE)(((BP_FP_INT_TYPE)v.getZ() & m_bpHandleMask) | isMax);
+#else
+	btVector3 v = (point - m_worldAabbMin) * m_quantize;
+	out[0]=(v[0]<=0)?(BP_FP_INT_TYPE)isMax:(v[0]>=m_handleSentinel)?(BP_FP_INT_TYPE)((m_handleSentinel&m_bpHandleMask)|isMax):(BP_FP_INT_TYPE)(((BP_FP_INT_TYPE)v[0]&m_bpHandleMask)|isMax);
+	out[1]=(v[1]<=0)?(BP_FP_INT_TYPE)isMax:(v[1]>=m_handleSentinel)?(BP_FP_INT_TYPE)((m_handleSentinel&m_bpHandleMask)|isMax):(BP_FP_INT_TYPE)(((BP_FP_INT_TYPE)v[1]&m_bpHandleMask)|isMax);
+	out[2]=(v[2]<=0)?(BP_FP_INT_TYPE)isMax:(v[2]>=m_handleSentinel)?(BP_FP_INT_TYPE)((m_handleSentinel&m_bpHandleMask)|isMax):(BP_FP_INT_TYPE)(((BP_FP_INT_TYPE)v[2]&m_bpHandleMask)|isMax);
+#endif //OLD_CLAMPING_METHOD
+}
+
+
+template <typename BP_FP_INT_TYPE>
+BP_FP_INT_TYPE btAxisSweep3Internal<BP_FP_INT_TYPE>::allocHandle()
+{
+	btAssert(m_firstFreeHandle);
+
+	BP_FP_INT_TYPE handle = m_firstFreeHandle;
+	m_firstFreeHandle = getHandle(handle)->GetNextFree();
+	m_numHandles++;
+
+	return handle;
+}
+
+template <typename BP_FP_INT_TYPE>
+void btAxisSweep3Internal<BP_FP_INT_TYPE>::freeHandle(BP_FP_INT_TYPE handle)
+{
+	btAssert(handle > 0 && handle < m_maxHandles);
+
+	getHandle(handle)->SetNextFree(m_firstFreeHandle);
+	m_firstFreeHandle = handle;
+
+	m_numHandles--;
+}
+
+
+template <typename BP_FP_INT_TYPE>
+BP_FP_INT_TYPE btAxisSweep3Internal<BP_FP_INT_TYPE>::addHandle(const btVector3& aabbMin,const btVector3& aabbMax, void* pOwner, int collisionFilterGroup, int collisionFilterMask,btDispatcher* dispatcher)
+{
+	// quantize the bounds
+	BP_FP_INT_TYPE min[3], max[3];
+	quantize(min, aabbMin, 0);
+	quantize(max, aabbMax, 1);
+
+	// allocate a handle
+	BP_FP_INT_TYPE handle = allocHandle();
+	
+
+	Handle* pHandle = getHandle(handle);
+	
+	pHandle->m_uniqueId = static_cast<int>(handle);
+	//pHandle->m_pOverlaps = 0;
+	pHandle->m_clientObject = pOwner;
+	pHandle->m_collisionFilterGroup = collisionFilterGroup;
+	pHandle->m_collisionFilterMask = collisionFilterMask;
+
+	// compute current limit of edge arrays
+	BP_FP_INT_TYPE limit = static_cast<BP_FP_INT_TYPE>(m_numHandles * 2);
+
+	
+	// insert new edges just inside the max boundary edge
+	for (BP_FP_INT_TYPE axis = 0; axis < 3; axis++)
+	{
+
+		m_pHandles[0].m_maxEdges[axis] += 2;
+
+		m_pEdges[axis][limit + 1] = m_pEdges[axis][limit - 1];
+
+		m_pEdges[axis][limit - 1].m_pos = min[axis];
+		m_pEdges[axis][limit - 1].m_handle = handle;
+
+		m_pEdges[axis][limit].m_pos = max[axis];
+		m_pEdges[axis][limit].m_handle = handle;
+
+		pHandle->m_minEdges[axis] = static_cast<BP_FP_INT_TYPE>(limit - 1);
+		pHandle->m_maxEdges[axis] = limit;
+	}
+
+	// now sort the new edges to their correct position
+	sortMinDown(0, pHandle->m_minEdges[0], dispatcher,false);
+	sortMaxDown(0, pHandle->m_maxEdges[0], dispatcher,false);
+	sortMinDown(1, pHandle->m_minEdges[1], dispatcher,false);
+	sortMaxDown(1, pHandle->m_maxEdges[1], dispatcher,false);
+	sortMinDown(2, pHandle->m_minEdges[2], dispatcher,true);
+	sortMaxDown(2, pHandle->m_maxEdges[2], dispatcher,true);
+
+
+	return handle;
+}
+
+
+template <typename BP_FP_INT_TYPE>
+void btAxisSweep3Internal<BP_FP_INT_TYPE>::removeHandle(BP_FP_INT_TYPE handle,btDispatcher* dispatcher)
+{
+
+	Handle* pHandle = getHandle(handle);
+
+	//explicitly remove the pairs containing the proxy
+	//we could do it also in the sortMinUp (passing true)
+	///@todo: compare performance
+	if (!m_pairCache->hasDeferredRemoval())
+	{
+		m_pairCache->removeOverlappingPairsContainingProxy(pHandle,dispatcher);
+	}
+
+	// compute current limit of edge arrays
+	int limit = static_cast<int>(m_numHandles * 2);
+	
+	int axis;
+
+	for (axis = 0;axis<3;axis++)
+	{
+		m_pHandles[0].m_maxEdges[axis] -= 2;
+	}
+
+	// remove the edges by sorting them up to the end of the list
+	for ( axis = 0; axis < 3; axis++)
+	{
+		Edge* pEdges = m_pEdges[axis];
+		BP_FP_INT_TYPE max = pHandle->m_maxEdges[axis];
+		pEdges[max].m_pos = m_handleSentinel;
+
+		sortMaxUp(axis,max,dispatcher,false);
+
+
+		BP_FP_INT_TYPE i = pHandle->m_minEdges[axis];
+		pEdges[i].m_pos = m_handleSentinel;
+
+
+		sortMinUp(axis,i,dispatcher,false);
+
+		pEdges[limit-1].m_handle = 0;
+		pEdges[limit-1].m_pos = m_handleSentinel;
+		
+#ifdef DEBUG_BROADPHASE
+			debugPrintAxis(axis,false);
+#endif //DEBUG_BROADPHASE
+
+
+	}
+
+
+	// free the handle
+	freeHandle(handle);
+
+	
+}
+
+template <typename BP_FP_INT_TYPE>
+void btAxisSweep3Internal<BP_FP_INT_TYPE>::resetPool(btDispatcher* /*dispatcher*/)
+{
+	if (m_numHandles == 0)
+	{
+		m_firstFreeHandle = 1;
+		{
+			for (BP_FP_INT_TYPE i = m_firstFreeHandle; i < m_maxHandles; i++)
+				m_pHandles[i].SetNextFree(static_cast<BP_FP_INT_TYPE>(i + 1));
+			m_pHandles[m_maxHandles - 1].SetNextFree(0);
+		}
+	}
+}       
+
+
+extern int gOverlappingPairs;
+//#include <stdio.h>
+
+template <typename BP_FP_INT_TYPE>
+void	btAxisSweep3Internal<BP_FP_INT_TYPE>::calculateOverlappingPairs(btDispatcher* dispatcher)
+{
+
+	if (m_pairCache->hasDeferredRemoval())
+	{
+	
+		btBroadphasePairArray&	overlappingPairArray = m_pairCache->getOverlappingPairArray();
+
+		//perform a sort, to find duplicates and to sort 'invalid' pairs to the end
+		overlappingPairArray.quickSort(btBroadphasePairSortPredicate());
+
+		overlappingPairArray.resize(overlappingPairArray.size() - m_invalidPair);
+		m_invalidPair = 0;
+
+		
+		int i;
+
+		btBroadphasePair previousPair;
+		previousPair.m_pProxy0 = 0;
+		previousPair.m_pProxy1 = 0;
+		previousPair.m_algorithm = 0;
+		
+		
+		for (i=0;i<overlappingPairArray.size();i++)
+		{
+		
+			btBroadphasePair& pair = overlappingPairArray[i];
+
+			bool isDuplicate = (pair == previousPair);
+
+			previousPair = pair;
+
+			bool needsRemoval = false;
+
+			if (!isDuplicate)
+			{
+				///important to use an AABB test that is consistent with the broadphase
+				bool hasOverlap = testAabbOverlap(pair.m_pProxy0,pair.m_pProxy1);
+
+				if (hasOverlap)
+				{
+					needsRemoval = false;//callback->processOverlap(pair);
+				} else
+				{
+					needsRemoval = true;
+				}
+			} else
+			{
+				//remove duplicate
+				needsRemoval = true;
+				//should have no algorithm
+				btAssert(!pair.m_algorithm);
+			}
+			
+			if (needsRemoval)
+			{
+				m_pairCache->cleanOverlappingPair(pair,dispatcher);
+
+		//		m_overlappingPairArray.swap(i,m_overlappingPairArray.size()-1);
+		//		m_overlappingPairArray.pop_back();
+				pair.m_pProxy0 = 0;
+				pair.m_pProxy1 = 0;
+				m_invalidPair++;
+				gOverlappingPairs--;
+			} 
+			
+		}
+
+	///if you don't like to skip the invalid pairs in the array, execute following code:
+	#define CLEAN_INVALID_PAIRS 1
+	#ifdef CLEAN_INVALID_PAIRS
+
+		//perform a sort, to sort 'invalid' pairs to the end
+		overlappingPairArray.quickSort(btBroadphasePairSortPredicate());
+
+		overlappingPairArray.resize(overlappingPairArray.size() - m_invalidPair);
+		m_invalidPair = 0;
+	#endif//CLEAN_INVALID_PAIRS
+		
+		//printf("overlappingPairArray.size()=%d\n",overlappingPairArray.size());
+	}
+
+}
+
+
+template <typename BP_FP_INT_TYPE>
+bool btAxisSweep3Internal<BP_FP_INT_TYPE>::testAabbOverlap(btBroadphaseProxy* proxy0,btBroadphaseProxy* proxy1)
+{
+	const Handle* pHandleA = static_cast<Handle*>(proxy0);
+	const Handle* pHandleB = static_cast<Handle*>(proxy1);
+	
+	//optimization 1: check the array index (memory address), instead of the m_pos
+
+	for (int axis = 0; axis < 3; axis++)
+	{ 
+		if (pHandleA->m_maxEdges[axis] < pHandleB->m_minEdges[axis] || 
+			pHandleB->m_maxEdges[axis] < pHandleA->m_minEdges[axis]) 
+		{ 
+			return false; 
+		} 
+	} 
+	return true;
+}
+
+template <typename BP_FP_INT_TYPE>
+bool btAxisSweep3Internal<BP_FP_INT_TYPE>::testOverlap2D(const Handle* pHandleA, const Handle* pHandleB,int axis0,int axis1)
+{
+	//optimization 1: check the array index (memory address), instead of the m_pos
+
+	if (pHandleA->m_maxEdges[axis0] < pHandleB->m_minEdges[axis0] || 
+		pHandleB->m_maxEdges[axis0] < pHandleA->m_minEdges[axis0] ||
+		pHandleA->m_maxEdges[axis1] < pHandleB->m_minEdges[axis1] ||
+		pHandleB->m_maxEdges[axis1] < pHandleA->m_minEdges[axis1]) 
+	{ 
+		return false; 
+	} 
+	return true;
+}
+
+template <typename BP_FP_INT_TYPE>
+void btAxisSweep3Internal<BP_FP_INT_TYPE>::updateHandle(BP_FP_INT_TYPE handle, const btVector3& aabbMin,const btVector3& aabbMax,btDispatcher* dispatcher)
+{
+//	btAssert(bounds.IsFinite());
+	//btAssert(bounds.HasVolume());
+
+	Handle* pHandle = getHandle(handle);
+
+	// quantize the new bounds
+	BP_FP_INT_TYPE min[3], max[3];
+	quantize(min, aabbMin, 0);
+	quantize(max, aabbMax, 1);
+
+	// update changed edges
+	for (int axis = 0; axis < 3; axis++)
+	{
+		BP_FP_INT_TYPE emin = pHandle->m_minEdges[axis];
+		BP_FP_INT_TYPE emax = pHandle->m_maxEdges[axis];
+
+		int dmin = (int)min[axis] - (int)m_pEdges[axis][emin].m_pos;
+		int dmax = (int)max[axis] - (int)m_pEdges[axis][emax].m_pos;
+
+		m_pEdges[axis][emin].m_pos = min[axis];
+		m_pEdges[axis][emax].m_pos = max[axis];
+
+		// expand (only adds overlaps)
+		if (dmin < 0)
+			sortMinDown(axis, emin,dispatcher,true);
+
+		if (dmax > 0)
+			sortMaxUp(axis, emax,dispatcher,true);
+
+		// shrink (only removes overlaps)
+		if (dmin > 0)
+			sortMinUp(axis, emin,dispatcher,true);
+
+		if (dmax < 0)
+			sortMaxDown(axis, emax,dispatcher,true);
+
+#ifdef DEBUG_BROADPHASE
+	debugPrintAxis(axis);
+#endif //DEBUG_BROADPHASE
+	}
+
+	
+}
+
+
+
+
+// sorting a min edge downwards can only ever *add* overlaps
+template <typename BP_FP_INT_TYPE>
+void btAxisSweep3Internal<BP_FP_INT_TYPE>::sortMinDown(int axis, BP_FP_INT_TYPE edge, btDispatcher* /* dispatcher */, bool updateOverlaps)
+{
+
+	Edge* pEdge = m_pEdges[axis] + edge;
+	Edge* pPrev = pEdge - 1;
+	Handle* pHandleEdge = getHandle(pEdge->m_handle);
+
+	while (pEdge->m_pos < pPrev->m_pos)
+	{
+		Handle* pHandlePrev = getHandle(pPrev->m_handle);
+
+		if (pPrev->IsMax())
+		{
+			// if previous edge is a maximum check the bounds and add an overlap if necessary
+			const int axis1 = (1  << axis) & 3;
+			const int axis2 = (1  << axis1) & 3;
+			if (updateOverlaps && testOverlap2D(pHandleEdge, pHandlePrev,axis1,axis2))
+			{
+				m_pairCache->addOverlappingPair(pHandleEdge,pHandlePrev);
+				if (m_userPairCallback)
+					m_userPairCallback->addOverlappingPair(pHandleEdge,pHandlePrev);
+
+				//AddOverlap(pEdge->m_handle, pPrev->m_handle);
+
+			}
+
+			// update edge reference in other handle
+			pHandlePrev->m_maxEdges[axis]++;
+		}
+		else
+			pHandlePrev->m_minEdges[axis]++;
+
+		pHandleEdge->m_minEdges[axis]--;
+
+		// swap the edges
+		Edge swap = *pEdge;
+		*pEdge = *pPrev;
+		*pPrev = swap;
+
+		// decrement
+		pEdge--;
+		pPrev--;
+	}
+
+#ifdef DEBUG_BROADPHASE
+	debugPrintAxis(axis);
+#endif //DEBUG_BROADPHASE
+
+}
+
+// sorting a min edge upwards can only ever *remove* overlaps
+template <typename BP_FP_INT_TYPE>
+void btAxisSweep3Internal<BP_FP_INT_TYPE>::sortMinUp(int axis, BP_FP_INT_TYPE edge, btDispatcher* dispatcher, bool updateOverlaps)
+{
+	Edge* pEdge = m_pEdges[axis] + edge;
+	Edge* pNext = pEdge + 1;
+	Handle* pHandleEdge = getHandle(pEdge->m_handle);
+
+	while (pNext->m_handle && (pEdge->m_pos >= pNext->m_pos))
+	{
+		Handle* pHandleNext = getHandle(pNext->m_handle);
+
+		if (pNext->IsMax())
+		{
+			Handle* handle0 = getHandle(pEdge->m_handle);
+			Handle* handle1 = getHandle(pNext->m_handle);
+			const int axis1 = (1  << axis) & 3;
+			const int axis2 = (1  << axis1) & 3;
+			
+			// if next edge is maximum remove any overlap between the two handles
+			if (updateOverlaps 
+#ifdef USE_OVERLAP_TEST_ON_REMOVES
+				&& testOverlap2D(handle0,handle1,axis1,axis2)
+#endif //USE_OVERLAP_TEST_ON_REMOVES
+				)
+			{
+				
+
+				m_pairCache->removeOverlappingPair(handle0,handle1,dispatcher);	
+				if (m_userPairCallback)
+					m_userPairCallback->removeOverlappingPair(handle0,handle1,dispatcher);
+				
+			}
+
+
+			// update edge reference in other handle
+			pHandleNext->m_maxEdges[axis]--;
+		}
+		else
+			pHandleNext->m_minEdges[axis]--;
+
+		pHandleEdge->m_minEdges[axis]++;
+
+		// swap the edges
+		Edge swap = *pEdge;
+		*pEdge = *pNext;
+		*pNext = swap;
+
+		// increment
+		pEdge++;
+		pNext++;
+	}
+
+
+}
+
+// sorting a max edge downwards can only ever *remove* overlaps
+template <typename BP_FP_INT_TYPE>
+void btAxisSweep3Internal<BP_FP_INT_TYPE>::sortMaxDown(int axis, BP_FP_INT_TYPE edge, btDispatcher* dispatcher, bool updateOverlaps)
+{
+
+	Edge* pEdge = m_pEdges[axis] + edge;
+	Edge* pPrev = pEdge - 1;
+	Handle* pHandleEdge = getHandle(pEdge->m_handle);
+
+	while (pEdge->m_pos < pPrev->m_pos)
+	{
+		Handle* pHandlePrev = getHandle(pPrev->m_handle);
+
+		if (!pPrev->IsMax())
+		{
+			// if previous edge was a minimum remove any overlap between the two handles
+			Handle* handle0 = getHandle(pEdge->m_handle);
+			Handle* handle1 = getHandle(pPrev->m_handle);
+			const int axis1 = (1  << axis) & 3;
+			const int axis2 = (1  << axis1) & 3;
+
+			if (updateOverlaps  
+#ifdef USE_OVERLAP_TEST_ON_REMOVES
+				&& testOverlap2D(handle0,handle1,axis1,axis2)
+#endif //USE_OVERLAP_TEST_ON_REMOVES
+				)
+			{
+				//this is done during the overlappingpairarray iteration/narrowphase collision
+
+				
+				m_pairCache->removeOverlappingPair(handle0,handle1,dispatcher);
+				if (m_userPairCallback)
+					m_userPairCallback->removeOverlappingPair(handle0,handle1,dispatcher);
+			
+
+
+			}
+
+			// update edge reference in other handle
+			pHandlePrev->m_minEdges[axis]++;;
+		}
+		else
+			pHandlePrev->m_maxEdges[axis]++;
+
+		pHandleEdge->m_maxEdges[axis]--;
+
+		// swap the edges
+		Edge swap = *pEdge;
+		*pEdge = *pPrev;
+		*pPrev = swap;
+
+		// decrement
+		pEdge--;
+		pPrev--;
+	}
+
+	
+#ifdef DEBUG_BROADPHASE
+	debugPrintAxis(axis);
+#endif //DEBUG_BROADPHASE
+
+}
+
+// sorting a max edge upwards can only ever *add* overlaps
+template <typename BP_FP_INT_TYPE>
+void btAxisSweep3Internal<BP_FP_INT_TYPE>::sortMaxUp(int axis, BP_FP_INT_TYPE edge, btDispatcher* /* dispatcher */, bool updateOverlaps)
+{
+	Edge* pEdge = m_pEdges[axis] + edge;
+	Edge* pNext = pEdge + 1;
+	Handle* pHandleEdge = getHandle(pEdge->m_handle);
+
+	while (pNext->m_handle && (pEdge->m_pos >= pNext->m_pos))
+	{
+		Handle* pHandleNext = getHandle(pNext->m_handle);
+
+		const int axis1 = (1  << axis) & 3;
+		const int axis2 = (1  << axis1) & 3;
+
+		if (!pNext->IsMax())
+		{
+			// if next edge is a minimum check the bounds and add an overlap if necessary
+			if (updateOverlaps && testOverlap2D(pHandleEdge, pHandleNext,axis1,axis2))
+			{
+				Handle* handle0 = getHandle(pEdge->m_handle);
+				Handle* handle1 = getHandle(pNext->m_handle);
+				m_pairCache->addOverlappingPair(handle0,handle1);
+				if (m_userPairCallback)
+					m_userPairCallback->addOverlappingPair(handle0,handle1);
+			}
+
+			// update edge reference in other handle
+			pHandleNext->m_minEdges[axis]--;
+		}
+		else
+			pHandleNext->m_maxEdges[axis]--;
+
+		pHandleEdge->m_maxEdges[axis]++;
+
+		// swap the edges
+		Edge swap = *pEdge;
+		*pEdge = *pNext;
+		*pNext = swap;
+
+		// increment
+		pEdge++;
+		pNext++;
+	}
+	
+}
+
+#endif
diff --git a/bullet/BulletCollision/Gimpact/btContactProcessingSructs.h b/bullet/BulletCollision/Gimpact/btContactProcessingSructs.h
new file mode 100644
index 0000000..cfd4bb1
--- /dev/null
+++ b/bullet/BulletCollision/Gimpact/btContactProcessingSructs.h
@@ -0,0 +1,138 @@
+#ifndef BT_CONTACT_H_STRUCTS_INCLUDED
+#define BT_CONTACT_H_STRUCTS_INCLUDED
+
+/*! \file gim_contact.h
+\author Francisco Leon Najera
+*/
+/*
+This source file is part of GIMPACT Library.
+
+For the latest info, see http://gimpact.sourceforge.net/
+
+Copyright (c) 2007 Francisco Leon Najera. C.C. 80087371.
+email: projectileman@yahoo.com
+
+
+This software is provided 'as-is', without any express or implied warranty.
+In no event will the authors be held liable for any damages arising from the use of this software.
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it freely,
+subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
+2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
+3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "LinearMath/btTransform.h"
+#include "LinearMath/btAlignedObjectArray.h"
+#include "btTriangleShapeEx.h"
+
+/**
+Configuration var for applying interpolation of  contact normals
+*/
+#define NORMAL_CONTACT_AVERAGE 1
+
+#define CONTACT_DIFF_EPSILON 0.00001f
+
+///The GIM_CONTACT is an internal GIMPACT structure, similar to btManifoldPoint.
+///@todo: remove and replace GIM_CONTACT by btManifoldPoint.
+class GIM_CONTACT
+{
+public:
+    btVector3 m_point;
+    btVector3 m_normal;
+    btScalar m_depth;//Positive value indicates interpenetration
+    btScalar m_distance;//Padding not for use
+    int m_feature1;//Face number
+    int m_feature2;//Face number
+public:
+    GIM_CONTACT()
+    {
+    }
+    
+    bool operator<(const GIM_CONTACT& obj) const {
+        return
+            m_point < obj.m_point &&
+            m_normal < obj.m_normal &&
+            m_depth < obj.m_depth &&
+            m_distance < obj.m_distance &&
+            m_feature1 < obj.m_feature1 &&
+            m_feature2 < obj.m_feature2;
+    }
+    
+    bool operator>(const GIM_CONTACT& obj) const {
+        return
+            m_point > obj.m_point &&
+            m_normal > obj.m_normal &&
+            m_depth > obj.m_depth &&
+            m_distance > obj.m_distance &&
+            m_feature1 > obj.m_feature1 &&
+            m_feature2 > obj.m_feature2;
+    }
+    
+    bool operator==(const GIM_CONTACT& obj) const {
+        return
+            m_point == obj.m_point &&
+            m_normal == obj.m_normal &&
+            m_depth == obj.m_depth &&
+            m_distance == obj.m_distance &&
+            m_feature1 == obj.m_feature1 &&
+            m_feature2 == obj.m_feature2;
+    }
+
+    GIM_CONTACT(const GIM_CONTACT & contact):
+				m_point(contact.m_point),
+				m_normal(contact.m_normal),
+				m_depth(contact.m_depth),
+				m_feature1(contact.m_feature1),
+				m_feature2(contact.m_feature2)
+    {
+    }
+
+    GIM_CONTACT(const btVector3 &point,const btVector3 & normal,
+    	 			btScalar depth, int feature1, int feature2):
+				m_point(point),
+				m_normal(normal),
+				m_depth(depth),
+				m_feature1(feature1),
+				m_feature2(feature2)
+    {
+    }
+
+	//! Calcs key for coord classification
+    SIMD_FORCE_INLINE unsigned int calc_key_contact() const
+    {
+    	int _coords[] = {
+    		(int)(m_point[0]*1000.0f+1.0f),
+    		(int)(m_point[1]*1333.0f),
+    		(int)(m_point[2]*2133.0f+3.0f)};
+		unsigned int _hash=0;
+		unsigned int *_uitmp = (unsigned int *)(&_coords[0]);
+		_hash = *_uitmp;
+		_uitmp++;
+		_hash += (*_uitmp)<<4;
+		_uitmp++;
+		_hash += (*_uitmp)<<8;
+		return _hash;
+    }
+
+    SIMD_FORCE_INLINE void interpolate_normals( btVector3 * normals,int normal_count)
+    {
+    	btVector3 vec_sum(m_normal);
+		for(int i=0;i<normal_count;i++)
+		{
+			vec_sum += normals[i];
+		}
+
+		btScalar vec_sum_len = vec_sum.length2();
+		if(vec_sum_len <CONTACT_DIFF_EPSILON) return;
+
+		//GIM_INV_SQRT(vec_sum_len,vec_sum_len); // 1/sqrt(vec_sum_len)
+
+		m_normal = vec_sum/btSqrt(vec_sum_len);
+    }
+
+};
+
+#endif // BT_CONTACT_H_STRUCTS_INCLUDED
diff --git a/bullet/BulletCollision/Gimpact/btGImpactBvhSructs.h b/bullet/BulletCollision/Gimpact/btGImpactBvhSructs.h
new file mode 100644
index 0000000..1e082fe
--- /dev/null
+++ b/bullet/BulletCollision/Gimpact/btGImpactBvhSructs.h
@@ -0,0 +1,161 @@
+#ifndef GIM_BOX_SET_STRUCT_H_INCLUDED
+#define GIM_BOX_SET_STRUCT_H_INCLUDED
+
+/*! \file gim_box_set.h
+\author Francisco Leon Najera
+*/
+/*
+This source file is part of GIMPACT Library.
+
+For the latest info, see http://gimpact.sourceforge.net/
+
+Copyright (c) 2007 Francisco Leon Najera. C.C. 80087371.
+email: projectileman@yahoo.com
+
+
+This software is provided 'as-is', without any express or implied warranty.
+In no event will the authors be held liable for any damages arising from the use of this software.
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it freely,
+subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
+2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
+3. This notice may not be removed or altered from any source distribution.
+*/
+
+
+#include "LinearMath/btAlignedObjectArray.h"
+
+#include "btBoxCollision.h"
+#include "btTriangleShapeEx.h"
+
+//! Overlapping pair
+struct GIM_PAIR
+{
+    int m_index1;
+    int m_index2;
+    
+    bool operator<(const GIM_PAIR& obj) const {
+        return
+            m_index1 < obj.m_index1 &&
+            m_index2 < obj.m_index2;
+    }
+    
+    bool operator>(const GIM_PAIR& obj) const {
+        return
+            m_index1 > obj.m_index1 &&
+            m_index2 > obj.m_index2;
+    }
+    
+    bool operator==(const GIM_PAIR& obj) const {
+        return
+            m_index1 == obj.m_index1 &&
+            m_index2 == obj.m_index2;
+    }
+    
+    GIM_PAIR()
+    {}
+
+    GIM_PAIR(const GIM_PAIR & p)
+    {
+    	m_index1 = p.m_index1;
+    	m_index2 = p.m_index2;
+	}
+
+	GIM_PAIR(int index1, int index2)
+    {
+    	m_index1 = index1;
+    	m_index2 = index2;
+	}
+};
+
+///GIM_BVH_DATA is an internal GIMPACT collision structure to contain axis aligned bounding box
+struct GIM_BVH_DATA
+{
+	btAABB m_bound;
+	int m_data;
+	
+    bool operator<(const GIM_BVH_DATA& obj) const {
+        return
+            m_bound < obj.m_bound &&
+            m_data < obj.m_data;
+    }
+    
+    bool operator>(const GIM_BVH_DATA& obj) const {
+        return
+            m_bound > obj.m_bound &&
+            m_data > obj.m_data;
+    }
+    
+    bool operator==(const GIM_BVH_DATA& obj) const {
+        return
+            m_bound == obj.m_bound &&
+            m_data == obj.m_data;
+    }
+};
+
+//! Node Structure for trees
+class GIM_BVH_TREE_NODE
+{
+public:
+	btAABB m_bound;
+protected:
+	int	m_escapeIndexOrDataIndex;
+public:
+
+    bool operator<(const GIM_BVH_TREE_NODE& obj) const {
+        return
+            m_bound < obj.m_bound &&
+            m_escapeIndexOrDataIndex < obj.m_escapeIndexOrDataIndex;
+    }
+    
+    bool operator>(const GIM_BVH_TREE_NODE& obj) const {
+        return
+            m_bound > obj.m_bound &&
+            m_escapeIndexOrDataIndex > obj.m_escapeIndexOrDataIndex;
+    }
+    
+    bool operator==(const GIM_BVH_TREE_NODE& obj) const {
+        return
+            m_bound == obj.m_bound &&
+            m_escapeIndexOrDataIndex == obj.m_escapeIndexOrDataIndex;
+    }
+    
+	GIM_BVH_TREE_NODE()
+	{
+		m_escapeIndexOrDataIndex = 0;
+	}
+
+	SIMD_FORCE_INLINE bool isLeafNode() const
+	{
+		//skipindex is negative (internal node), triangleindex >=0 (leafnode)
+		return (m_escapeIndexOrDataIndex>=0);
+	}
+
+	SIMD_FORCE_INLINE int getEscapeIndex() const
+	{
+		//btAssert(m_escapeIndexOrDataIndex < 0);
+		return -m_escapeIndexOrDataIndex;
+	}
+
+	SIMD_FORCE_INLINE void setEscapeIndex(int index)
+	{
+		m_escapeIndexOrDataIndex = -index;
+	}
+
+	SIMD_FORCE_INLINE int getDataIndex() const
+	{
+		//btAssert(m_escapeIndexOrDataIndex >= 0);
+
+		return m_escapeIndexOrDataIndex;
+	}
+
+	SIMD_FORCE_INLINE void setDataIndex(int index)
+	{
+		m_escapeIndexOrDataIndex = index;
+	}
+
+};
+
+#endif // GIM_BOXPRUNING_H_INCLUDED
diff --git a/bullet/BulletCollision/Gimpact/btGImpactQuantizedBvhSructs.h b/bullet/BulletCollision/Gimpact/btGImpactQuantizedBvhSructs.h
new file mode 100644
index 0000000..acd7b16
--- /dev/null
+++ b/bullet/BulletCollision/Gimpact/btGImpactQuantizedBvhSructs.h
@@ -0,0 +1,124 @@
+#ifndef GIM_QUANTIZED_SET_STRUCTS_H_INCLUDED
+#define GIM_QUANTIZED_SET_STRUCTS_H_INCLUDED
+
+/*! \file btGImpactQuantizedBvh.h
+\author Francisco Leon Najera
+*/
+/*
+This source file is part of GIMPACT Library.
+
+For the latest info, see http://gimpact.sourceforge.net/
+
+Copyright (c) 2007 Francisco Leon Najera. C.C. 80087371.
+email: projectileman@yahoo.com
+
+
+This software is provided 'as-is', without any express or implied warranty.
+In no event will the authors be held liable for any damages arising from the use of this software.
+Permission is granted to anyone to use this software for any purpose,
+including commercial applications, and to alter it and redistribute it freely,
+subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
+2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
+3. This notice may not be removed or altered from any source distribution.
+*/
+
+#include "btGImpactBvh.h"
+#include "btQuantization.h"
+
+///btQuantizedBvhNode is a compressed aabb node, 16 bytes.
+///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).
+ATTRIBUTE_ALIGNED16	(struct) BT_QUANTIZED_BVH_NODE
+{
+	//12 bytes
+	unsigned short int	m_quantizedAabbMin[3];
+	unsigned short int	m_quantizedAabbMax[3];
+	//4 bytes
+	int	m_escapeIndexOrDataIndex;
+
+    bool operator<(const BT_QUANTIZED_BVH_NODE& obj) const {
+        return
+            m_quantizedAabbMin[0] < obj.m_quantizedAabbMin[0] &&
+            m_quantizedAabbMin[1] < obj.m_quantizedAabbMin[1] &&
+            m_quantizedAabbMin[2] < obj.m_quantizedAabbMin[2] &&
+            m_quantizedAabbMax[0] < obj.m_quantizedAabbMax[0] &&
+            m_quantizedAabbMax[1] < obj.m_quantizedAabbMax[1] &&
+            m_quantizedAabbMax[2] < obj.m_quantizedAabbMax[2] &&
+            m_escapeIndexOrDataIndex < obj.m_escapeIndexOrDataIndex;
+    }
+    
+    bool operator>(const BT_QUANTIZED_BVH_NODE& obj) const {
+        return
+            m_quantizedAabbMin[0] > obj.m_quantizedAabbMin[0] &&
+            m_quantizedAabbMin[1] > obj.m_quantizedAabbMin[1] &&
+            m_quantizedAabbMin[2] > obj.m_quantizedAabbMin[2] &&
+            m_quantizedAabbMax[0] > obj.m_quantizedAabbMax[0] &&
+            m_quantizedAabbMax[1] > obj.m_quantizedAabbMax[1] &&
+            m_quantizedAabbMax[2] > obj.m_quantizedAabbMax[2] &&
+            m_escapeIndexOrDataIndex > obj.m_escapeIndexOrDataIndex;
+    }
+    
+    bool operator==(const BT_QUANTIZED_BVH_NODE& obj) const {
+        return
+            m_quantizedAabbMin[0] == obj.m_quantizedAabbMin[0] &&
+            m_quantizedAabbMin[1] == obj.m_quantizedAabbMin[1] &&
+            m_quantizedAabbMin[2] == obj.m_quantizedAabbMin[2] &&
+            m_quantizedAabbMax[0] == obj.m_quantizedAabbMax[0] &&
+            m_quantizedAabbMax[1] == obj.m_quantizedAabbMax[1] &&
+            m_quantizedAabbMax[2] == obj.m_quantizedAabbMax[2] &&
+            m_escapeIndexOrDataIndex == obj.m_escapeIndexOrDataIndex;
+    }
+    
+	BT_QUANTIZED_BVH_NODE()
+	{
+		m_escapeIndexOrDataIndex = 0;
+	}
+
+	SIMD_FORCE_INLINE bool isLeafNode() const
+	{
+		//skipindex is negative (internal node), triangleindex >=0 (leafnode)
+		return (m_escapeIndexOrDataIndex>=0);
+	}
+
+	SIMD_FORCE_INLINE int getEscapeIndex() const
+	{
+		//btAssert(m_escapeIndexOrDataIndex < 0);
+		return -m_escapeIndexOrDataIndex;
+	}
+
+	SIMD_FORCE_INLINE void setEscapeIndex(int index)
+	{
+		m_escapeIndexOrDataIndex = -index;
+	}
+
+	SIMD_FORCE_INLINE int getDataIndex() const
+	{
+		//btAssert(m_escapeIndexOrDataIndex >= 0);
+
+		return m_escapeIndexOrDataIndex;
+	}
+
+	SIMD_FORCE_INLINE void setDataIndex(int index)
+	{
+		m_escapeIndexOrDataIndex = index;
+	}
+
+	SIMD_FORCE_INLINE bool testQuantizedBoxOverlapp(
+		unsigned short * quantizedMin,unsigned short * quantizedMax) const
+	{
+		if(m_quantizedAabbMin[0] > quantizedMax[0] ||
+		   m_quantizedAabbMax[0] < quantizedMin[0] ||
+		   m_quantizedAabbMin[1] > quantizedMax[1] ||
+		   m_quantizedAabbMax[1] < quantizedMin[1] ||
+		   m_quantizedAabbMin[2] > quantizedMax[2] ||
+		   m_quantizedAabbMax[2] < quantizedMin[2])
+		{
+			return false;
+		}
+		return true;
+	}
+
+};
+
+#endif // GIM_QUANTIZED_SET_STRUCTS_H_INCLUDED
-- 
2.11.1.windows.1

